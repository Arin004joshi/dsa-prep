{
  "metadata": {
    "totalProblems": 31,
    "lastUpdated": "2025-08-26T20:42:11.305Z",
    "breakdown": {
      "Codechef": {
        "total": 4,
        "Easy": 1,
        "Medium": 3,
        "Hard": 0
      },
      "Gfg": {
        "total": 11,
        "Easy": 7,
        "Medium": 3,
        "Hard": 1
      },
      "Leetcode": {
        "total": 9,
        "Easy": 3,
        "Medium": 5,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 7,
        "Easy": 0,
        "Medium": 7,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "codechef-easy-saving-taxes",
      "platform": "Codechef",
      "difficulty": "Easy",
      "problemName": "Saving Taxes",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    \r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        long long X, Y;\r\n        cin >> X >> Y;\r\n        cout << (X - Y) << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Saving Taxes\n\nIn Chefland, everyone who earns strictly more than \nùëå\nY rupees per year, has to pay a tax to Chef. Chef has allowed a special scheme where you can invest any amount of money and claim exemption for it.\n\nYou have earned \nùëã\nX \n(\nùëã\n>\nùëå\n)\n(X>Y) rupees this year. Find the minimum amount of money you have to invest so that you don't have to pay taxes this year.\n\nInput Format\nThe first line of input will contain a single integer \nùëá\nT, denoting the number of test cases.\nEach test case consists of a single line of input consisting of two space separated integers \nùëã\nX and \nùëå\nY denoting the amount you earned and the amount above which you will have to pay taxes.\nOutput Format\n\nFor each test case, output a single integer, denoting the minimum amount you need to invest.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n100\n1‚â§T‚â§100\n1\n‚â§\nùëå\n<\nùëã\n‚â§\n100\n1‚â§Y<X‚â§100\nSample 1:\nInput\nOutput\n4\n4 2\n8 7\n5 1\n2 1\n\n2\n1\n4\n1\n\nExplanation:\n\nTest case \n1\n1: The amount above which you will have to pay taxes is \n2\n2. Since you earn \n4\n4 rupees, you need to invest at least \n2\n2 rupees. After investing \n2\n2 rupees, you will remain with an effective income \n4\n‚àí\n2\n=\n2\n4‚àí2=2 rupees which will not be taxed.\n\nTest case \n2\n2: The amount above which you will have to pay taxes is \n7\n7. Since you earn \n8\n8 rupees, you need to invest at least \n1\n1 rupees.\n\nTest case \n3\n3: The amount above which you will have to pay taxes is \n1\n1. Since you earn \n5\n5 rupees, you need to invest at least \n4\n4 rupees.\n\nTest case \n4\n4: The amount above which you will have to pay taxes is \n1\n1. Since you earn \n2\n2 rupees, you need to invest at least \n1\n1 rupees.",
        "notes": "# Saving Taxes\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.148Z"
    },
    {
      "id": "codechef-medium-bitwise-tuples",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Bitwise Tuples",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst long long MOD = 1e9 + 7;\r\n\r\n// fast exponentiation\r\nlong long modpow(long long base, long long exp, long long mod) {\r\n    long long result = 1;\r\n    base %= mod;\r\n    while (exp > 0) {\r\n        if (exp & 1) result = (result * base) % mod;\r\n        base = (base * base) % mod;\r\n        exp >>= 1;\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    \r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        long long N, M;\r\n        cin >> N >> M;\r\n        \r\n        long long base = (modpow(2, N, MOD) - 1 + MOD) % MOD;\r\n        long long ans = modpow(base, M, MOD);\r\n        \r\n        cout << ans << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Bitwise Tuples\nRead problem statements in Vietnamese,\n\nBengali, Mandarin Chinese, and Russian as well.\n\nChef has two numbers \nùëÅ\nN and \nùëÄ\nM. Help Chef to find number of integer \nùëÅ\nN-tuples \n(\nùê¥\n1\n,\nùê¥\n2\n,\n‚Ä¶\n,\nùê¥\nùëÅ\n)\n(A\n1\n\t‚Äã\n\n,A\n2\n\t‚Äã\n\n,‚Ä¶,A\nN\n\t‚Äã\n\n) such that \n0\n‚â§\nùê¥\n1\n,\nùê¥\n2\n,\n‚Ä¶\n,\nùê¥\nùëÅ\n‚â§\n2\nùëÄ\n‚àí\n1\n0‚â§A\n1\n\t‚Äã\n\n,A\n2\n\t‚Äã\n\n,‚Ä¶,A\nN\n\t‚Äã\n\n‚â§2\nM\n‚àí1 and \nùê¥\n1\n&\nùê¥\n2\n&\n‚Ä¶\n&\nùê¥\nùëÅ\n=\n0\nA\n1\n\t‚Äã\n\n&A\n2\n\t‚Äã\n\n&‚Ä¶&A\nN\n\t‚Äã\n\n=0, where \n&\n& denotes the bitwise AND operator.\n\nSince the number of tuples can be large, output it modulo \n10\n9\n+\n7\n10\n9\n+7.\n\nInput\nThe first line contains a single integer \nùëá\nT denoting the number of test cases. The description of \nùëá\nT test cases follows.\nThe first and only line of each test case contains two integers \nùëÅ\nN and \nùëÄ\nM.\nOutput\n\nFor each test case, output in a single line the answer to the problem modulo \n10\n9\n+\n7\n10\n9\n+7.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n10\n5\n1‚â§T‚â§10\n5\n1\n‚â§\nùëÅ\n,\nùëÄ\n‚â§\n10\n6\n1‚â§N,M‚â§10\n6\n\n###Subtasks Subtask #1 (100 points): original constraints\n\nSample 1:\nInput\nOutput\n4\n1 2\n2 2\n4 2\n8 4\n1\n9\n225\n228250597\nExplanation:\n\nTest Case \n1\n1: The only possible tuple is \n(\n0\n)\n(0).\n\nTest Case \n2\n2: The tuples are \n(\n0\n,\n0\n)\n(0,0), \n(\n0\n,\n1\n)\n(0,1), \n(\n0\n,\n2\n)\n(0,2), \n(\n0\n,\n3\n)\n(0,3), \n(\n1\n,\n0\n)\n(1,0), \n(\n2\n,\n0\n)\n(2,0), \n(\n3\n,\n0\n)\n(3,0), \n(\n1\n,\n2\n)\n(1,2), \n(\n2\n,\n1\n)\n(2,1).",
        "notes": "# Bitwise Tuples\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.150Z"
    },
    {
      "id": "codechef-medium-plusle-and-minun-on-array",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Plusle and Minun on Array",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        int N;\r\n        cin >> N;\r\n        vector<long long> A(N+1);\r\n        for (int i = 1; i <= N; i++) cin >> A[i];\r\n\r\n        long long base = 0;\r\n        long long minOdd = LLONG_MAX, maxEven = LLONG_MIN;\r\n\r\n        for (int i = 1; i <= N; i++) {\r\n            long long val = abs(A[i]);\r\n            if (i % 2 == 1) { // odd index -> positive\r\n                base += val;\r\n                minOdd = min(minOdd, val);\r\n            } else { // even index -> negative\r\n                base -= val;\r\n                maxEven = max(maxEven, val);\r\n            }\r\n        }\r\n\r\n        long long delta = 0;\r\n        if (minOdd != LLONG_MAX && maxEven != LLONG_MIN) {\r\n            delta = max(0LL, (maxEven - minOdd) * 2);\r\n        }\r\n\r\n        cout << base + delta << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Plusle and Minun on Array\n\nChef has an array \nùê¥\nA of length \nùëÅ\nN. He defines the alternating sum of the array as:\n\nùëÜ\n=\n‚à£\nùê¥\n1\n‚à£\n‚àí\n‚à£\nùê¥\n2\n‚à£\n+\n‚à£\nùê¥\n3\n‚à£\n‚àí\n‚à£\nùê¥\n4\n‚à£\n+\n‚Ä¶\n(\n‚àí\n1\n)\nùëÅ\n‚àí\n1\n‚ãÖ\n‚à£\nùê¥\nùëÅ\n‚à£\nS=‚à£A\n1\n\t‚Äã\n\n‚à£‚àí‚à£A\n2\n\t‚Äã\n\n‚à£+‚à£A\n3\n\t‚Äã\n\n‚à£‚àí‚à£A\n4\n\t‚Äã\n\n‚à£+‚Ä¶(‚àí1)\nN‚àí1\n‚ãÖ‚à£A\nN\n\t‚Äã\n\n‚à£\n\nChef is allowed to perform the following operation on the array at most once:\n\nChoose two indices \nùëñ\ni and \nùëó\nj \n(\n1\n‚â§\nùëñ\n<\nùëó\n‚â§\nùëÅ\n)\n(1‚â§i<j‚â§N) and swap the elements \nùê¥\nùëñ\nA\ni\n\t‚Äã\n\n and \nùê¥\nùëó\nA\nj\n\t‚Äã\n\n.\n\nFind the maximum alternating sum Chef can achieve by performing the operation at most once.\n\nNote: \n‚à£\nùëã\n‚à£\n‚à£X‚à£ denotes the absolute value of \nùëã\nX. For example, \n‚à£\n‚àí\n4\n‚à£\n=\n4\n‚à£‚àí4‚à£=4 and \n‚à£\n7\n‚à£\n=\n7\n‚à£7‚à£=7.\n\nInput Format\nThe first line will contain \nùëá\nT - the number of test cases. Then the test cases follow.\nFirst line of each test case contains a single integer \nùëÅ\nN - size of the array \nùê¥\nA.\nSecond line of each test case contains \nùëÅ\nN space separated integers - denoting the elements of array \nùê¥\nA.\nOutput Format\n\nFor each testcase, output in a single line, the maximum alternating sum Chef can obtain by performing the operation at most once.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n10\n5\n1‚â§T‚â§10\n5\n2\n‚â§\nùëÅ\n‚â§\n10\n5\n2‚â§N‚â§10\n5\n‚àí\n10\n9\n‚â§\nùê¥\nùëñ\n‚â§\n10\n9\n‚àí10\n9\n‚â§A\ni\n\t‚Äã\n\n‚â§10\n9\nSum of \nùëÅ\nN over all test cases does not exceed \n2\n‚ãÖ\n10\n5\n2‚ãÖ10\n5\n.\nSample 1:\nInput\nOutput\n2\n2\n10 -10\n7\n-3 -2 -1 0 1 2 3\n\n0\n6\n\nExplanation:\n\nTest Case \n1\n1: One optimal way is to perform no operations. Thus the alternating sum is \n‚à£\n10\n‚à£\n‚àí\n‚à£\n‚àí\n10\n‚à£\n=\n10\n‚àí\n10\n=\n0\n‚à£10‚à£‚àí‚à£‚àí10‚à£=10‚àí10=0.\n\nTest Case \n2\n2: One optimal way is to choose \nùëñ\n=\n2\ni=2 and \nùëó\n=\n5\nj=5. After swapping, the array is \n[\n‚àí\n3\n,\n1\n,\n‚àí\n1\n,\n0\n,\n‚àí\n2\n,\n2\n,\n3\n]\n[‚àí3,1,‚àí1,0,‚àí2,2,3]. The alternating sum in this case is \n‚à£\n‚àí\n3\n‚à£\n‚àí\n‚à£\n1\n‚à£\n+\n‚à£\n‚àí\n1\n‚à£\n‚àí\n‚à£\n0\n‚à£\n+\n‚à£\n‚àí\n2\n‚à£\n‚àí\n‚à£\n2\n‚à£\n+\n‚à£\n3\n‚à£\n=\n6\n‚à£‚àí3‚à£‚àí‚à£1‚à£+‚à£‚àí1‚à£‚àí‚à£0‚à£+‚à£‚àí2‚à£‚àí‚à£2‚à£+‚à£3‚à£=6.",
        "notes": "# Plusle and Minun on Array\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.151Z"
    },
    {
      "id": "codechef-medium-reversing-directions",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Reversing directions",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        int N;\r\n        cin >> N;\r\n        cin.ignore(); // clear newline\r\n\r\n        vector<string> instr(N);\r\n        for (int i = 0; i < N; i++) {\r\n            getline(cin, instr[i]);\r\n        }\r\n\r\n        // Reverse directions\r\n        string prevRoad = \"\";\r\n        for (int i = N - 1; i >= 0; i--) {\r\n            string s = instr[i];\r\n            if (i == N - 1) {\r\n                // Last instruction in original becomes \"Begin\"\r\n                size_t pos = s.find(\" on \");\r\n                string road = s.substr(pos + 4);\r\n                cout << \"Begin on \" << road << \"\\n\";\r\n                prevRoad = road;\r\n            } else {\r\n                size_t pos = s.find(\" on \");\r\n                string turn = s.substr(0, pos); // \"Left\" or \"Right\" or \"Begin\"\r\n                string road = s.substr(pos + 4);\r\n\r\n                if (turn == \"Left\")\r\n                    cout << \"Right on \" << prevRoad << \"\\n\";\r\n                else if (turn == \"Right\")\r\n                    cout << \"Left on \" << prevRoad << \"\\n\";\r\n                else if (turn == \"Begin\")\r\n                    cout << \"Begin on \" << prevRoad << \"\\n\";\r\n\r\n                prevRoad = road;\r\n            }\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.152Z"
    },
    {
      "id": "gfg-easy-array-duplicates",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Array Duplicates",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> findDuplicates(vector<int>& arr) {\r\n        vector<int> ans;\r\n        int n = arr.size();\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            int x = abs(arr[i]);\r\n            if (arr[x - 1] < 0) {\r\n                ans.push_back(x);\r\n            } else {\r\n                arr[x - 1] = -arr[x - 1];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.154Z"
    },
    {
      "id": "gfg-easy-binary-search",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Binary Search",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int binarysearch(vector<int> &arr, int k) {\r\n        int left = 0, right = arr.size() - 1;\r\n        int ans = -1;   // store index of k if found\r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2;\r\n\r\n            if (arr[mid] == k) {\r\n                ans = mid;       // potential answer\r\n                right = mid - 1; // keep looking left for smaller index\r\n            } \r\n            else if (arr[mid] < k) {\r\n                left = mid + 1;\r\n            } \r\n            else {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};",
        "readme": "Binary Search\nDifficulty: EasyAccuracy: 44.32%Submissions: 631K+Points: 2Average Time: 20m\n\nGiven a sorted array arr[] and an integer k, find the position(0-based indexing) at which k is present in the array using binary search. If k doesn't exist in arr[] return -1.¬†\n\nNote: If multiple occurrences are there, please return the smallest index.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4, 5], k = 4\nOutput: 3\nExplanation: 4 appears at index 3.\nInput: arr[] = [11, 22, 33, 44, 55], k = 445\nOutput: -1\nExplanation: 445 is not present.\n\nInput: arr[] = [1, 1, 1, 1, 2], k = 1\nOutput: 0\nExplanation: 1 appears at index 0.\n\nConstraints:\n1 ‚â§ arr.size() ‚â§ 105\n1 ‚â§ arr[i] ‚â§ 106\n1 ‚â§ k ‚â§ 106\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "# Binary Search\n\n          **Summary:** This code implements a solution using C++ (12). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.155Z"
    },
    {
      "id": "gfg-easy-check-for-bst",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Check for BST",
      "language": "cpp",
      "files": {
        "code": "/*\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n*/\n\nclass Solution {\n  public:\n    // Helper function with range limits\n    bool helper(Node* root, long long minVal, long long maxVal) {\n        if (!root) return true;\n\n        if (root->data <= minVal || root->data >= maxVal) {\n            return false;\n        }\n\n        // Left subtree must be < root->data\n        // Right subtree must be > root->data\n        return helper(root->left, minVal, root->data) &&\n               helper(root->right, root->data, maxVal);\n    }\n\n    // Function to check whether a Binary Tree is BST or not.\n    bool isBST(Node* root) {\n        return helper(root, LLONG_MIN, LLONG_MAX);\n    }\n};",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.156Z"
    },
    {
      "id": "gfg-easy-lcm-and-gcd",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "LCM And GCD",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int gcd(int a, int b) {\r\n        while (b != 0) {\r\n            int temp = b;\r\n            b = a % b;\r\n            a = temp;\r\n        }\r\n        return a;\r\n    }\r\n    \r\n    vector<int> lcmAndGcd(int a, int b) {\r\n        int gcd_val = gcd(a, b);\r\n        long long lcm_val = (1LL * a * b) / gcd_val;\r\n        \r\n        vector<int> ans;\r\n        ans.push_back((int)lcm_val);\r\n        ans.push_back(gcd_val);\r\n        return ans;\r\n    }\r\n};",
        "readme": "LCM And GCD\nDifficulty: BasicAccuracy: 37.02%Submissions: 222K+Points: 1\n\nGiven two integers a and b, You have to compute their LCM and GCD and return an array containing their LCM and GCD.\n\nExamples:\n\nInput: a = 5 , b = 10\nOutput: [10, 5]\nExplanation: LCM of 5 and 10 is 10, while their GCD is 5.\nInput: a = 14 , b = 8\nOutput: [56, 2]\nExplanation: LCM of 14 and 8 is 56, while their GCD is 2.\n\nInput: a = 1 , b = 1\nOutput: [1, 1]\nExplanation: LCM of 1 and 1 is 1, while their GCD is 1.\n\nConstraints:\n1 ‚â§ a, b ‚â§ 104\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": "LCM And GCD\n\n          - Summary: The code uses a vector to store the calculated least common multiple (LCM) and greatest common divisor (GCD) of two input integers.  It first calculates the GCD using Euclid's algorithm, iteratively reducing the numbers until the remainder is zero. Then, it calculates the LCM using the formula (a * b) / GCD(a, b), ensuring to use long long to prevent integer overflow. Finally, it stores the LCM and GCD in a vector and returns it.\n\n          - Time Complexity: O(log(min(a, b))) because the GCD function using Euclid's algorithm has a time complexity of O(log(min(a, b))). The remaining operations are constant time.\n          - Space Complexity: O(1) as the algorithm uses a fixed amount of space irrespective of the input size.  The vector used to store the result has a constant size of 2."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.157Z"
    },
    {
      "id": "gfg-easy-missing-in-array",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Missing in Array",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int missingNum(vector<int>& arr) {\r\n        int n = arr.size() + 1;  // since one number is missing\r\n        long long total = 1LL * n * (n + 1) / 2;  // expected sum\r\n        long long actual = 0;\r\n        for (int x : arr) actual += x;\r\n        return (int)(total - actual);\r\n    }\r\n};",
        "readme": "Missing in Array\nDifficulty: EasyAccuracy: 29.59%Submissions: 1.5MPoints: 2Average Time: 15m\n\nYou are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.\n\n\nConstraints:\n1 ‚â§ arr.size() ‚â§ 106\n1 ‚â§ arr[i] ‚â§ arr.size() + 1\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "# Missing in Array\n\n          **Summary:** This code implements a solution using C++ (12). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.158Z"
    },
    {
      "id": "gfg-easy-print-1-to-n-without-loop",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Print 1 To N Without Loop",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    void printNos(int n) {\r\n        if (n == 0) return;         // base case\r\n        printNos(n - 1);            // recursive call\r\n        cout << n << \" \";           // print after recursion\r\n    }\r\n};",
        "readme": "Print 1 To N Without Loop\nDifficulty: BasicAccuracy: 61.33%Submissions: 322K+Points: 1\n\nYou are given an integer n. You have¬† to print all numbers from 1 to n.\nNote:¬†You must use recursion only, and print all numbers from 1 to n in a single line, separated by spaces.\n\nExamples:\n\n\nInput: n = 10\nOutput: 1 2 3 4 5 6 7 8 9 10\n\nInput: n = 5\nOutput: 1 2 3 4 5\nInput: n = 1\nOutput: 1\n\nConstraints:\n1 ‚â§ n ‚â§ 103\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.159Z"
    },
    {
      "id": "gfg-easy-string-rotated-by-2-places",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "String Rotated by 2 Places",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    bool isRotated(string& s1, string& s2) {\r\n        if (s1.length() != s2.length()) return false;\r\n        if (s1.length() < 2) return s1 == s2;\r\n        \r\n        // Left rotation by 2\r\n        string leftRot = s1.substr(2) + s1.substr(0, 2);\r\n        \r\n        // Right rotation by 2\r\n        string rightRot = s1.substr(s1.size() - 2) + s1.substr(0, s1.size() - 2);\r\n        \r\n        return (s2 == leftRot || s2 == rightRot);\r\n    }\r\n};",
        "readme": "String Rotated by 2 Places\nDifficulty: EasyAccuracy: 32.7%Submissions: 253K+Points: 2Average Time: 20m\n\nGiven two strings s1 and s2. Return true if the string s2 can be obtained by rotating¬†(in any direction) string s1 by exactly 2 places, otherwise, false.\n\nNote: Both rotations should be performed in same direction chosen initially.\n\nExamples:\n\nInput: s1 = \"amazon\", s2 = \"azonam\"\nOutput: true\nExplanation: \"amazon\" can be rotated anti-clockwise by two places, which will make it as \"azonam\".\n\nInput: s1 = \"geeksforgeeks\", s2 = \"geeksgeeksfor\"\nOutput: false\nExplanation: If we rotate \"geeksforgeeks\" by two place in any direction, we won't get \"geeksgeeksfor\".\n\nInput: s1 = \"ab\", s2 = \"ab\"\nOutput: true\nExplanation: If we rotate \"ab\" by two place in any direction, we always get \"ab\".\n\nConstraints:\n1 ‚â§ s1.length, s2.length ‚â§ 105\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.160Z"
    },
    {
      "id": "gfg-medium-bellman-ford",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Bellman-Ford",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> bellmanFord(int V, vector<vector<int>>& edges, int src) {\r\n        const int INF = 100000000;  // must be exactly 1e8\r\n        vector<int> dist(V, INF);\r\n        dist[src] = 0;\r\n        \r\n        for (int i = 1; i <= V - 1; i++) {\r\n            bool changed = false;\r\n            for (auto &e : edges) {\r\n                int u = e[0], v = e[1], w = e[2];\r\n                if (dist[u] != INF && dist[u] + w < dist[v]) {\r\n                    dist[v] = dist[u] + w;\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed) break;\r\n        }\r\n        \r\n        for (auto &e : edges) {\r\n            int u = e[0], v = e[1], w = e[2];\r\n            if (dist[u] != INF && dist[u] + w < dist[v]) {\r\n                return {-1};\r\n            }\r\n        }\r\n        \r\n        return dist;\r\n    }\r\n};",
        "readme": "Bellman-Ford\nDifficulty: MediumAccuracy: 48.11%Submissions: 227K+Points: 4Average Time: 25m\n\nGiven an weighted graph with V vertices numbered from 0 to V-1 and E edges, represented by a 2d array edges[][], where edges[i] = [u, v, w] represents a direct edge from node u to v having w edge weight. You are also given a source vertex src.\n\nYour task is to compute the shortest distances from the source to all other vertices. If a vertex is unreachable from the source, its distance should be marked as 108. Additionally, if the graph contains a negative weight cycle, return [-1] to indicate that shortest paths cannot be reliably computed.\n\nExamples:\n\nInput: V = 5, edges[][] = [[1, 3, 2], [4, 3, -1], [2, 4, 1], [1, 2, 1], [0, 1, 5]], src = 0\n\nOutput: [0, 5, 6, 6, 7]\nExplanation: Shortest Paths:\nFor 0 to 1 minimum distance will be 5. By following path 0 ‚Üí 1\nFor 0 to 2 minimum distance will be 6. By following path 0 ‚Üí 1  ‚Üí 2\nFor 0 to 3 minimum distance will be 6. By following path 0 ‚Üí 1  ‚Üí 2 ‚Üí 4 ‚Üí 3 \nFor 0 to 4 minimum distance will be 7. By following path 0 ‚Üí 1  ‚Üí 2 ‚Üí 4\n\nInput: V = 4, edges[][] = [[0, 1, 4], [1, 2, -6], [2, 3, 5], [3, 1, -2]], src = 0\n\nOutput: [-1]\nExplanation: The graph contains a negative weight cycle formed by the path 1 ‚Üí 2 ‚Üí 3 ‚Üí 1, where the total weight of the cycle is negative.\n\n\nConstraints:\n1 ‚â§ V ‚â§ 100\n1 ‚â§ E = edges.size() ‚â§ V*(V-1)\n-1000 ‚â§ w ‚â§ 1000\n0 ‚â§ src < V\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.161Z"
    },
    {
      "id": "gfg-medium-indexes-of-subarray-sum",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Indexes of Subarray Sum",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> subarraySum(vector<int> &arr, int target) {\r\n        int n = arr.size();\r\n        int start = 0;\r\n        long long sum = 0; // use long long to avoid overflow\r\n\r\n        for (int end = 0; end < n; end++) {\r\n            sum += arr[end];\r\n\r\n            // shrink the window if sum exceeds target\r\n            while (sum > target && start <= end) {\r\n                sum -= arr[start];\r\n                start++;\r\n            }\r\n\r\n            // check if sum matches\r\n            if (sum == target) {\r\n                return {start + 1, end + 1}; // 1-based indices\r\n            }\r\n        }\r\n        return {-1}; // if no subarray found\r\n    }\r\n};",
        "readme": "Indexes of Subarray Sum\nDifficulty: MediumAccuracy: 16.5%Submissions: 1.8MPoints: 4Average Time: 20m\n\nGiven an array arr[] containing only non-negative integers, your task is to find a continuous subarray (a contiguous sequence of elements) whose sum equals a specified value target. You need to return the 1-based indices of the leftmost and rightmost elements of this subarray. You need to find the first subarray whose sum is equal to the target.\n\nNote: If no such array is possible then, return [-1].\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 7, 5], target = 12\nOutput: [2, 4]\nExplanation: The sum of elements from 2nd to 4th position is 12.\nInput: arr[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 15\nOutput: [1, 5]\nExplanation: The sum of elements from 1st to 5th position is 15.\n\nInput: arr[] = [5, 3, 4], target = 2\nOutput: [-1]\nExplanation: There is no subarray with sum 2.\n\nConstraints:\n1 <= arr.size()<= 106\n0 <= arr[i] <= 103\n0 <=¬†target <= 109\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.162Z"
    },
    {
      "id": "gfg-medium-undirected-graph-cycle",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Undirected Graph Cycle",
      "language": "java",
      "files": {
        "code": "import java.util.*;\r\n\r\nclass Solution {\r\n    public boolean isCycle(int V, int[][] edges) {\r\n        // Build adjacency list\r\n        List<List<Integer>> adj = new ArrayList<>();\r\n        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\r\n\r\n        for (int[] edge : edges) {\r\n            int u = edge[0], v = edge[1];\r\n            adj.get(u).add(v);\r\n            adj.get(v).add(u); // undirected graph\r\n        }\r\n\r\n        boolean[] visited = new boolean[V];\r\n\r\n        // Check all components\r\n        for (int i = 0; i < V; i++) {\r\n            if (!visited[i]) {\r\n                if (dfs(i, -1, visited, adj)) {\r\n                    return true; // cycle found\r\n                }\r\n            }\r\n        }\r\n\r\n        return false; // no cycle\r\n    }\r\n\r\n    // DFS helper function\r\n    private boolean dfs(int node, int parent, boolean[] visited, List<List<Integer>> adj) {\r\n        visited[node] = true;\r\n\r\n        for (int neigh : adj.get(node)) {\r\n            if (!visited[neigh]) {\r\n                if (dfs(neigh, node, visited, adj)) return true;\r\n            } \r\n            // if neighbor is visited and not parent -> cycle\r\n            else if (neigh != parent) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}",
        "readme": "Undirected Graph Cycle\nDifficulty: MediumAccuracy: 30.13%Submissions: 630K+Points: 4Average Time: 20m\n\nGiven an undirected graph with V vertices and E edges, represented as a 2D vector edges[][], where each entry edges[i] = [u, v] denotes an edge between vertices u and v, determine whether the graph contains a cycle or not. The graph can have multiple component.\n\nExamples:\n\nInput: V = 4, E = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 3]]\nOutput: true\nExplanation: \n \n1 -> 2 -> 0 -> 1 is a cycle.\n\nInput: V = 4, E = 3, edges[][] = [[0, 1], [1, 2], [2, 3]]\nOutput: false\nExplanation: \n \nNo cycle in the graph.\n\n\nConstraints:\n1¬†‚â§ V¬†‚â§¬†105\n1 ‚â§ E = edges.size() ‚â§ 105\n\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "# Undirected Graph Cycle\n\n          **Summary:** This code implements a solution using Java (21). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.163Z"
    },
    {
      "id": "gfg-hard-edit-distance",
      "platform": "Gfg",
      "difficulty": "Hard",
      "problemName": "Edit Distance",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int editDistance(string& s1, string& s2) {\r\n        int n = s1.size(), m = s2.size();\r\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\r\n        \r\n        // Base cases\r\n        for (int i = 0; i <= n; i++) dp[i][0] = i;  // remove all\r\n        for (int j = 0; j <= m; j++) dp[0][j] = j;  // insert all\r\n        \r\n        // DP relation\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (s1[i - 1] == s2[j - 1]) {\r\n                    dp[i][j] = dp[i - 1][j - 1];  // no operation\r\n                } else {\r\n                    dp[i][j] = 1 + min({\r\n                        dp[i - 1][j],     // remove\r\n                        dp[i][j - 1],     // insert\r\n                        dp[i - 1][j - 1]  // replace\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return dp[n][m];\r\n    }\r\n};",
        "readme": "Edit Distance\nDifficulty: HardAccuracy: 35.14%Submissions: 243K+Points: 8\n\nGiven two strings s1 and s2. Return the minimum number of operations required to convert s1 to s2.\nThe possible operations are permitted:\n\nInsert a character at any position of the string.\nRemove any character from the string.\nReplace any character from the string with any other character.\n\nExamples:\n\n\nInput: s1 = \"geek\", s2 = \"gesek\"\nOutput:¬†1\nExplanation: One operation is required, inserting 's' between two 'e' in s1.\nInput: s1 = \"gfg\", s2 = \"gfg\"\nOutput: 0\nExplanation: Both strings are same.\n\nInput: s1 = \"abcd\", s2 = \"bcfe\"\nOutput: 3\nExplanation: We can convert s1 into s2 by removing ‚Äòa‚Äô, replacing ‚Äòd‚Äô with ‚Äòf‚Äô and inserting ‚Äòe‚Äô at the end. \n\nConstraints:\n1 ‚â§ s1.length(), s2.length() ‚â§ 103\nBoth the strings are in lowercase.\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": "# Edit Distance\n\n          **Summary:** This code implements a solution using C++ (12). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.164Z"
    },
    {
      "id": "hackerrank-medium-array-manipulation",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Array Manipulation",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'arrayManipulation' function below.\n *\n * The function is expected to return a LONG_INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER n\n *  2. 2D_INTEGER_ARRAY queries\n */\n\nlong arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long long> arr(n + 2, 0);\n\n    for (auto &q : queries) {\n        int a = q[0], b = q[1], k = q[2];\n        arr[a] += k;\n        arr[b + 1] -= k;\n    }\n\n    long long maxVal = 0, curr = 0;\n    for (int i = 1; i <= n; i++) {\n        curr += arr[i];\n        maxVal = max(maxVal, curr);\n    }\n\n    return maxVal;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int m = stoi(first_multiple_input[1]);\n\n    vector<vector<int>> queries(m);\n\n    for (int i = 0; i < m; i++) {\n        queries[i].resize(3);\n\n        string queries_row_temp_temp;\n        getline(cin, queries_row_temp_temp);\n\n        vector<string> queries_row_temp = split(rtrim(queries_row_temp_temp));\n\n        for (int j = 0; j < 3; j++) {\n            int queries_row_item = stoi(queries_row_temp[j]);\n\n            queries[i][j] = queries_row_item;\n        }\n    }\n\n    long result = arrayManipulation(n, queries);\n\n    fout << result << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\n\nExample\n\n\n\nQueries are interpreted as follows:\n\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\n\n\nAdd the values of  between the indices  and  inclusive:\n\nThe largest value is  after all operations are performed.\n\nFunction Description\n\nComplete the function  with the following parameters:\n\n: the number of elements in the array\n: a two dimensional array of queries where each  contains three integers, , , and .\n\nReturns\n\n: the maximum value in the resultant array\n\nInput Format\n\nThe first line contains two space-separated integers  and , the size of the array and the number of queries.\nEach of the next  lines contains three space-separated integers ,  and , the left index, right index and number to add.\n\nConstraints\n\nSample Input\n\nSTDIN       Function\n-----       --------\n5 3         arr[] size n = 5, queries[] size q = 3\n1 2 100     queries = [[1, 2, 100], [2, 5, 100], [3, 4, 100]]\n2 5 100\n3 4 100\n\n\nSample Output\n\n200\n\n\nExplanation\n\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\n\nThe maximum value is .",
        "notes": "# Array Manipulation\n\n          **Summary:** This code implements a solution using C++11. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.176Z"
    },
    {
      "id": "hackerrank-medium-arrays---ds",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Arrays - DS",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'reverseArray' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts INTEGER_ARRAY a as parameter.\n */\n\nvector<int> reverseArray(vector<int> a) {\n    reverse(a.begin(), a.end());  // use STL reverse\n    return a;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(arr_count);\n\n    for (int i = 0; i < arr_count; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> res = reverseArray(arr);\n\n    for (size_t i = 0; i < res.size(); i++) {\n        fout << res[i];\n\n        if (i != res.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "An array is a data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  or .\n\nYour task is to reverse an array of integers.\n\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\n\nExample\n\n\nReturn .\n\nFunction Description\n\nComplete the function  with the following parameter(s):\n\n: the array to reverse\n\nReturns\n\n: the reversed array\n\nInput Format\n\nThe first line contains an integer, , the number of integers in .\nThe second line contains  space-separated integers that make up .\n\nConstraints",
        "notes": "# Arrays - DS\n\n          **Summary:** This code implements a solution using C++11. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.177Z"
    },
    {
      "id": "hackerrank-medium-binary-search-tree---insertion",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Binary Search Tree : Insertion",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n\nclass Solution {\n    public:\n  \t\n  \tvoid preOrder(Node *root) {\n\t\t\n      \tif( root == NULL )\n          \treturn;\n      \n      \tstd::cout << root->data << \" \";\n      \t\n      \tpreOrder(root->left);\n      \tpreOrder(root->right);\n    }\n\n/*\nNode is defined as \n\nclass Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n\n*/\n\n    Node * insert(Node * root, int data) {\n    if (root == NULL) {\n        return new Node(data);\n    }\n\n    if (data <= root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n\n    return root;\n}\n\n\n};\n\nint main() {\n  \n    Solution myTree;\n    Node* root = NULL;\n    \n    int t;\n    int data;\n\n    std::cin >> t;\n\n    while(t-- > 0) {\n        std::cin >> data;\n        root = myTree.insert(root, data);\n    }\n  \t\n    myTree.preOrder(root);\n  \n    return 0;\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.178Z"
    },
    {
      "id": "hackerrank-medium-find-merge-point-of-two-lists",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Find Merge Point of Two Lists",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n// Complete the findMergeNode function below.\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\nint findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {\n    // Step 1: compute lengths of both lists\n    int len1 = 0, len2 = 0;\n    SinglyLinkedListNode* curr1 = head1;\n    SinglyLinkedListNode* curr2 = head2;\n\n    while (curr1) {\n        len1++;\n        curr1 = curr1->next;\n    }\n    while (curr2) {\n        len2++;\n        curr2 = curr2->next;\n    }\n\n    // Step 2: advance the longer list by the difference in lengths\n    curr1 = head1;\n    curr2 = head2;\n    if (len1 > len2) {\n        int diff = len1 - len2;\n        while (diff--) curr1 = curr1->next;\n    } else {\n        int diff = len2 - len1;\n        while (diff--) curr2 = curr2->next;\n    }\n\n    // Step 3: move both pointers until they meet\n    while (curr1 && curr2) {\n        if (curr1 == curr2) {\n            return curr1->data; // found merge point\n        }\n        curr1 = curr1->next;\n        curr2 = curr2->next;\n    }\n\n    return -1; // should not happen given the problem guarantee\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int tests;\n    cin >> tests;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {\n        int index;\n        cin >> index;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        SinglyLinkedList* llist1 = new SinglyLinkedList();\n\n        int llist1_count;\n        cin >> llist1_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist1_count; i++) {\n            int llist1_item;\n            cin >> llist1_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist1->insert_node(llist1_item);\n        }\n      \n      \tSinglyLinkedList* llist2 = new SinglyLinkedList();\n\n        int llist2_count;\n        cin >> llist2_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist2_count; i++) {\n            int llist2_item;\n            cin >> llist2_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist2->insert_node(llist2_item);\n        }\n      \n      \tSinglyLinkedListNode* ptr1 = llist1->head;\n      \tSinglyLinkedListNode* ptr2 = llist2->head;\n      \n      \tfor (int i = 0; i < llist1_count; i++) {\n            if (i < index) {\n          \t\tptr1 = ptr1->next;\n            }\n        }\n      \n      \tfor (int i = 0; i < llist2_count; i++) {\n          \tif (i != llist2_count-1) {\n          \t\tptr2 = ptr2->next;\n            }\n        }\n      \n      \tptr2->next = ptr1;\n\n        int result = findMergeNode(llist1->head, llist2->head);\n\n        fout << result << \"\\n\";\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "This challenge is part of a tutorial track by MyCodeSchool\n\nGiven pointers to the head nodes of  linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's  value.\n\nNote: After the merge point, both lists will share the same node pointers.\n\nExample\n\nIn the diagram below, the two lists converge at Node x:\n\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     /\n     [List #2] p--->q\n\n\nFunction Description\n\nComplete the findMergeNode function in the editor below.\n\nfindMergeNode has the following parameters:\n\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\n\nReturns\n\nint: the  value of the node where the lists merge\n\nInput Format\n\nDo not read any input from stdin/console.\n\nThe first line contains an integer , the number of test cases.\n\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer,  that is the number of nodes in the first list.\nEach of the following  lines contains a  value for a node. The next line contains an integer,  that is the number of nodes in the second list.\nEach of the following  lines contains a  value for a node.\n\nConstraints\n\nThe lists will merge.\n.\n .\n\nSample Input\n\nThe diagrams below are graphical representations of the lists that input nodes  and  are connected to.\n\nTest Case 0\n\n 1\n  \\\n   2--->3--->NULL\n  /\n 1\n\n\nTest Case 1\n\n1--->2\n      \\\n       3--->Null\n      /\n     1\n\n\nSample Output\n\n2\n3\n\n\nExplanation\n\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.178Z"
    },
    {
      "id": "hackerrank-medium-inserting-a-node-into-a-sorted-doubly-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Inserting a Node Into a Sorted Doubly Linked List",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass DoublyLinkedListNode {\n    public:\n        int data;\n        DoublyLinkedListNode *next;\n        DoublyLinkedListNode *prev;\n\n        DoublyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n            this->prev = nullptr;\n        }\n};\n\nclass DoublyLinkedList {\n    public:\n        DoublyLinkedListNode *head;\n        DoublyLinkedListNode *tail;\n\n        DoublyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            DoublyLinkedListNode* node = new DoublyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n                node->prev = this->tail;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_doubly_linked_list(DoublyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_doubly_linked_list(DoublyLinkedListNode* node) {\n    while (node) {\n        DoublyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n/*\n * Complete the 'sortedInsert' function below.\n *\n * The function is expected to return an INTEGER_DOUBLY_LINKED_LIST.\n * The function accepts following parameters:\n *  1. INTEGER_DOUBLY_LINKED_LIST llist\n *  2. INTEGER data\n */\n\n/*\n * For your reference:\n *\n * DoublyLinkedListNode {\n *     int data;\n *     DoublyLinkedListNode* next;\n *     DoublyLinkedListNode* prev;\n * };\n *\n */\n\nDoublyLinkedListNode* sortedInsert(DoublyLinkedListNode* llist, int data) {\n    DoublyLinkedListNode* newNode = new DoublyLinkedListNode(data);\n\n    // Case 1: empty list\n    if (!llist) {\n        return newNode;\n    }\n\n    // Case 2: insert before head\n    if (data <= llist->data) {\n        newNode->next = llist;\n        llist->prev = newNode;\n        return newNode; // new head\n    }\n\n    // Case 3: traverse to find insertion point\n    DoublyLinkedListNode* curr = llist;\n    while (curr->next && curr->next->data < data) {\n        curr = curr->next;\n    }\n\n    // Insert after curr\n    newNode->next = curr->next;\n    newNode->prev = curr;\n    if (curr->next) {\n        curr->next->prev = newNode;\n    }\n    curr->next = newNode;\n\n    return llist; // head remains unchanged\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int t;\n    cin >> t;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int t_itr = 0; t_itr < t; t_itr++) {\n        DoublyLinkedList* llist = new DoublyLinkedList();\n\n        int llist_count;\n        cin >> llist_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist_count; i++) {\n            int llist_item;\n            cin >> llist_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist->insert_node(llist_item);\n        }\n\n        int data;\n        cin >> data;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        DoublyLinkedListNode* llist1 = sortedInsert(llist->head, data);\n\n        print_doubly_linked_list(llist1, \" \", fout);\n        fout << \"\\n\";\n\n        free_doubly_linked_list(llist1);\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value  and insert it at the proper location to maintain the sort.\n\nExample\n\n refers to the list \n\n\nReturn a reference to the new list: .\n\nFunction Description\n\nComplete the sortedInsert function in the editor below.\n\nsortedInsert has two parameters:\n\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\n\nint data: An integer denoting the value of the  field for the DoublyLinkedListNode you must insert into the list.\n\nReturns\n\nDoublyLinkedListNode pointer: a reference to the head of the list\n\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\n\nInput Format\n\nThe first line contains an integer , the number of test cases.\n\nEach of the test case is in the following format:\n\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next  lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\n\nConstraints\n\nSample Input\n\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\n\n\nSample Output\n\n1 3 4 5 10\n\n\nExplanation\n\nThe initial doubly linked list is:  .\n\nThe doubly linked list after insertion is:",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.179Z"
    },
    {
      "id": "hackerrank-medium-left-rotation",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Left Rotation",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'rotateLeft' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts following parameters:\n *  1. INTEGER d\n *  2. INTEGER_ARRAY arr\n */\n\nvector<int> rotateLeft(int d, vector<int> arr) {\n    int n = arr.size();\n    d = d % n; // handle cases when d >= n\n    vector<int> rotated(n);\n\n    for (int i = 0; i < n; i++) {\n        rotated[i] = arr[(i + d) % n];\n    }\n\n    return rotated;\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int d = stoi(first_multiple_input[1]);\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(n);\n\n    for (int i = 0; i < n; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> result = rotateLeft(d, arr);\n\n    for (size_t i = 0; i < result.size(); i++) {\n        fout << result[i];\n\n        if (i != result.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "A  operation on a circular array shifts each of the array's elements  unit to the left. The elements that fall off the left end reappear at the right end. Given an integer , rotate the array that many steps to the left and return the result.\n\nExample\n\n\n\nAfter  rotations, .\n\nFunction Description\n\nComplete the  function with the following parameters:\n\n: the amount to rotate by\n: the array to rotate\n\nReturns\n\n: the rotated array\n\nInput Format\n\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains  space-separated integers that describe .\n\nConstraints\n\nSample Input\n\nSTDIN      Function\n-----      --------\n5 4         n = 5 d = 4\n1 2 3 4 5  arr = [1, 2, 3, 4, 5]\n\n\nSample Output\n\n5 1 2 3 4\n\n\nExplanation\n\nTo perform  left rotations, the array undergoes the following sequence of changes:",
        "notes": "# Left Rotation\n\n          **Summary:** This code implements a solution using C++11. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.180Z"
    },
    {
      "id": "hackerrank-medium-reverse-a-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Reverse a linked list",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n/*\n * Complete the 'reverse' function below.\n *\n * The function is expected to return an INTEGER_SINGLY_LINKED_LIST.\n * The function accepts INTEGER_SINGLY_LINKED_LIST llist as parameter.\n */\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\n\nSinglyLinkedListNode* reverse(SinglyLinkedListNode* llist) {\n    SinglyLinkedListNode* prev = nullptr;\n    SinglyLinkedListNode* curr = llist;\n\n    while (curr != nullptr) {\n        SinglyLinkedListNode* nextNode = curr->next; // save next\n        curr->next = prev;                           // reverse pointer\n        prev = curr;                                 // move prev\n        curr = nextNode;                             // move curr\n    }\n\n    return prev; // new head\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int tests;\n    cin >> tests;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {\n        SinglyLinkedList* llist = new SinglyLinkedList();\n\n        int llist_count;\n        cin >> llist_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist_count; i++) {\n            int llist_item;\n            cin >> llist_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist->insert_node(llist_item);\n        }\n\n        SinglyLinkedListNode* llist1 = reverse(llist->head);\n\n        print_singly_linked_list(llist1, \" \", fout);\n        fout << \"\\n\";\n\n        free_singly_linked_list(llist1);\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\n\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\n\nExample\n references the list \n\nManipulate the  pointers of each node in place and return , now referencing the head of the list .\n\nFunction Description\n\nComplete the reverse function in the editor below.\n\nreverse has the following parameter:\n\nSinglyLinkedListNode pointer head: a reference to the head of a list\n\nReturns\n\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\n\nInput Format\n\nThe first line contains an integer , the number of test cases.\n\nEach test case has the following format:\n\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next  lines contains an integer, the  values of the elements in the linked list.\n\nConstraints\n\n, where  is the  element in the list.\n\nSample Input\n\n1\n5\n1\n2\n3\n4\n5\n\n\nSample Output\n\n5 4 3 2 1 \n\n\nExplanation\n\nThe initial linked list is: .\n\nThe reversed linked list is: .",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.181Z"
    },
    {
      "id": "leetcode-easy-remove-duplicates-from-sorted-list",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Remove Duplicates from Sorted List",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) return nullptr;\n        \n        ListNode* curr = head;\n        while (curr && curr->next) {\n            if (curr->val == curr->next->val) {\n                // Skip the duplicate node\n                ListNode* temp = curr->next;\n                curr->next = curr->next->next;\n                delete temp;  // free memory if needed\n            } else {\n                curr = curr->next;\n            }\n        }\n        return head;\n    }\n};",
        "readme": "83. Remove Duplicates from Sorted ListSolvedEasyTopicsCompaniesGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\n¬†\nExample 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n\n¬†\nConstraints:\n\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,054,992/3.7MAcceptance Rate55.3%TopicsLinked ListCompaniesSimilar QuestionsRemove Duplicates from Sorted List IIMediumRemove Duplicates From an Unsorted Linked ListMediumDiscussion (135)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestM1dn1ghtNov 12, 2023if this was easy i dont even want to see a medium linked list problem¬†Read more15715LeetCanCodeSep 07, 2023Additional tests:\n[1,1,1]\n[1,2,2]\n[1,1,2,3,3]\n[1,1,2,2,3,3]\n[1,2,2,3]\n[1]\n[]\n[1,1]¬†Read moreTip574anlunxJun 13, 2019Why give a null test case?¬†Read more273SamikshaApr 22, 2022Hi.\nI'm new to python programming. It'd be very helpful if someone can explain why do we use Optional?\n'''\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n'''\n**Here, why do we use Optional[ListNode]? How is it useful? **¬†Read more257AaryanSep 10, 2023Simple Approach\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\n\n\nInitialize a pointer to head, here I used 'temp' and iterate it over the linked list.\n\n\nIn each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of 'temp' to temp->next->next;\n\n\nWhile we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\n\n\nBut if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values.\n\n¬†Read moreTip225rostikcode15Mar 29, 2025FIRST TIME, solved some easy leetcode problem in less then 20 minutes, i am so proud of myself, lezzgo¬†Read more121rashmi_jain18Nov 03, 2022Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\nvar current = head;\nwhile (current.next != null) {\nif (current.next.val == current.val) {\ncurrent.next = current.next.next;\n}\nelse {\ncurrent = current.next;\n}\n}\nIs it because its reference type?¬†Read moreAsk Question106NicaishishaDec 29, 2013In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here.¬†Read more84Shivam SharmaSep 27, 2024Move to the next node only when data in the next node is not equal.\nThis will be helpful test cases like [1, 1, 1].¬†Read moreTip71yuuJan 08, 2025Linked lists aint real¬†Read more3123414Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.166Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "python",
      "files": {
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pair_idx = {}\n\n        for i, num in enumerate(nums):\n            if target - num in pair_idx:\n                return [i, pair_idx[target - num]]\n            pair_idx[num] = i",
        "readme": "1. Two SumSolvedEasyTopicsCompaniesHintGiven an array of integers nums¬†and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n¬†\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n¬†\nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n¬†\nFollow-up:¬†Can you come up with an algorithm that is less than O(n2)¬†time complexity?¬†Seen this question in a real interview before?1/5YesNoAccepted18,521,883/33MAcceptance Rate56.2%TopicsArrayHash TableCompaniesHint 1A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.Hint 2So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?Hint 3The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?Similar Questions3SumMedium4SumMediumTwo Sum II - Input Array Is SortedMediumTwo Sum III - Data structure designEasySubarray Sum Equals KMediumTwo Sum IV - Input is a BSTEasyTwo Sum Less Than KEasyMax Number of K-Sum PairsMediumCount Good MealsMediumCount Number of Pairs With Absolute Difference KEasyNumber of Pairs of Strings With Concatenation Equal to TargetMediumFind All K-Distant Indices in an ArrayEasyFirst Letter to Appear TwiceEasyNumber of Excellent PairsHardNumber of Arithmetic TripletsEasyNode With Highest Edge ScoreMediumCheck Distances Between Same LettersEasyFind Subarrays With Equal SumEasyLargest Positive Integer That Exists With Its NegativeEasyNumber of Distinct AveragesEasyCount Pairs Whose Sum is Less than TargetEasyDiscussion (1.5K)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestVinay Kumar patApr 09, 2019Hello all,\nI'm new coding and noob in using classes. why no one is writing int main() in their codes. Definetly there will be different versions in the main() i.e taking input from STDIN, passing arguments to class etc.¬†Read more83976AlgoEngineApr 29, 2023Video visualizing how a hash table can reduce the runtime from O(n^2) to O(n):\n¬†Read more46812winstonchiMar 10, 2016In interview, I was asked what if duplicates exists.. How do we handle this?\nMy original thought is worst case nums = [1,1,1,1] target is 2\nthen the complexity if N^2... Is it true?\nIs there any way to improve this?¬†Read more27751CafogarN4May 24, 2024Not that easy¬†Read more1967AlexTheGreatNov 04, 2014Can't find a better place to ask this...\nEvery time I passed a problem, it's marked with a green check mark.\nIf I want to redo all the problems for the second round, is there a way to \"reset\" all the marks?¬†Read more16517Xu ZHANGMay 13, 2016We can see a lot of HashMap solutions using a HashMap to store the number as the key and the index as the value.\nMany people will come up the same questions that what if there have duplicate numbers in the array?\nWell, it's not a problem at all. Because in the description, it says there is exactly one solution. I will prove it here:\n\n\nSay we have three N1 in the array like this [N1, N2, N1, N3, N1], then N1 will not be part of the result with N2 or N3, since if N1 is part of the result, then we have three solutions which go against the description. N1 cannot be part of result with itself neither since then we have three solutions again. So in this case, we do not care duplicates at all.\n\n\nSo the only possible situation that the N1 can be the result is: N1 MUST only have two of them, and the target MUST be 2 * N1, then we have an array like this: [N1, N2, N1], and a target like this 2 * N1. In this case, after building up the map, N1's index will be the right most one which is 2. Then when we start from the first N1 at index 0, we do (target - N1) and get N1, and then query the N1's index in the array, which is 2, and then we can get the result which is [0, 2] with no problem.\n\n¬†Read more1417CodeBumblebeeJun 11, 2024this is easy? im cooked¬†Read moreFeedback872Ming YueJan 15, 2014O(n^2) I got Time Limit Exceed. Does anyone got accept by O(n^2) ? I just use binary search and finally accept.¬†Read more5824shaguvFeb 01, 2015Sorry for the newbie question: is there any way to read the test cases for a given problem? Even after having validated it, I couldn't find how to access them.\nPS: At the moment of posting this general question, I realize I need to assign it a particular problem as a category. So I guess this is the wrong place to ask. Could you redirect me to some \"meta\" forum?¬†Read more781Mikhail LachikhinNov 19, 2019Hello there. This is my first time solving problems on leetcode and I ran into a problem. The output of my code is [0, 1], and the output expected is [0,1]. But yet, site says im wrong. Also I see my output in \"stdout\", not in the \"Output\" line. I used \"print()\" method for output. How should I do it instead? image¬†Read more68171234153Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "Two Sum\n\n          - Summary: This Java code utilizes a HashMap to efficiently find two numbers within an array that sum up to a target value.  It first populates the HashMap with array elements as keys and their indices as values. Then, it iterates through the array, checking if the complement (target - current element) exists in the HashMap. If the complement is found and its index differs from the current element's index, it signifies a pair that sums to the target, and their indices are returned. Otherwise, the search continues.\n\n          - Time Complexity: O(n) because the code iterates through the input array once to populate the HashMap and then iterates through it again at most once to find the pair. HashMap operations (put and get) take constant time on average.\n          - Space Complexity: O(n) as the HashMap stores a maximum of n key-value pairs, where n is the length of the input array.  The space used grows linearly with the input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.167Z"
    },
    {
      "id": "leetcode-easy-valid-anagram",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Valid Anagram",
      "language": "java",
      "files": {
        "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        // HashMap <Character,Integer> mapS = new HashMap<>();\n        // HashMap <Character,Integer> mapT = new HashMap<>();\n\n        // for(int i=0;i<s.length();i++){\n        //     char charS = s.charAt(i);     \n        //     char charT = t.charAt(i);\n            \n        //     // \n        //     mapS.put(charS, mapS.getOrDefault(charS, 0) + 1);\n        //     mapT.put(charT, mapT.getOrDefault(charT, 0) + 1);\n        // }\n        // return mapS.equals(mapT);\n        char[] originalArr = s.toCharArray();\n        char[] modifiedArr = t.toCharArray();\n\n        Arrays.sort(originalArr);\n        Arrays.sort(modifiedArr);\n\n        return Arrays.equals(originalArr, modifiedArr);\n    }\n}",
        "readme": "242. Valid AnagramSolvedEasyTopicsCompaniesGiven two strings s and t, return true if t is an anagram of s, and false otherwise.\n\n¬†\nExample 1:\n\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false\n\n\n¬†\nConstraints:\n\n\n\t1 <= s.length, t.length <= 5 * 104\n\ts and t consist of lowercase English letters.\n\n\n¬†\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?\n¬†Seen this question in a real interview before?1/5YesNoAccepted5,151,529/7.7MAcceptance Rate67.0%TopicsHash TableStringSortingCompaniesSimilar QuestionsGroup AnagramsMediumPalindrome PermutationEasyFind All Anagrams in a StringMediumFind Resultant Array After Removing AnagramsEasyDiscussion (277)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestMuhsin Ali KulbakDec 16, 2023¬†Read more2365Shaikh Jashir AhmedJul 12, 2023bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???¬†Read more597Lubor LiuJan 04, 2016Any discussion on how to handle the unicode?¬†Read more5213Ram GoswamiMar 07, 2022If t is the anagram of s then by comparing both sorted strings can give the answer\nIf t is amagram of s then sorted t must be same as sorted s so,\n\"\"\"\nreturn sorted(s) == sorted(t)\n\"\"\"¬†Read more11310AlecDec 16, 2023¬†Read more653AlgoEngineAug 12, 2023Visualization of hash table approach\n¬†Read more40enamespaceMay 16, 2019when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\ni wonder whether it's math trick or it's simply a his hash function ?\ni guess it's a hash function with big probability to ensure no collision so far.\n¬†Read more214Iqra SarwarJan 17, 2023why it is t anagram of s when it is have testcases like\ns=\"ab\"\nt=\"a\"\nand\ns=\"a\"\nt=\"ab\"\nboth giving false. isn't it should be both strings anagram of each other?¬†Read more177JacksonJun 15, 2017There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?¬†Read more264harnalerohanApr 20, 2022var isAnagram = (s, t) => s.split('').sort().join('') === t.split('').sort().join('') ? true : false¬†Read more225123428Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.168Z"
    },
    {
      "id": "leetcode-medium-combination-sum-ii",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Combination Sum II",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> curr;\n\n    void backtrack(vector<int>& candidates, int target, int start) {\n        if (target == 0) {\n            res.push_back(curr);\n            return;\n        }\n\n        for (int i = start; i < candidates.size(); i++) {\n            // Skip duplicates\n            if (i > start && candidates[i] == candidates[i - 1]) continue;\n\n            if (candidates[i] > target) break; // pruning\n\n            curr.push_back(candidates[i]);\n            backtrack(candidates, target - candidates[i], i + 1);\n            curr.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtrack(candidates, target, 0);\n        return res;\n    }\n};",
        "readme": "40. Combination Sum IISolvedMediumTopicsCompaniesGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates¬†where the candidate numbers sum to target.\n\nEach number in candidates¬†may only be used once in the combination.\n\nNote:¬†The solution set must not contain duplicate combinations.\n\n¬†\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n¬†\nConstraints:\n\n\n\t1 <=¬†candidates.length <= 100\n\t1 <=¬†candidates[i] <= 50\n\t1 <= target <= 30\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted1,477,286/2.5MAcceptance Rate58.1%TopicsArrayBacktrackingCompaniesSimilar QuestionsCombination SumMediumDiscussion (191)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:Bestananta_srivastavaJan 17, 2023where in the question is it mentioned that th ans should be in sorted order?¬†Read more28710Nachiketa BhoraniyaMar 07, 2023to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\ntarget = 29¬†Read more86PurdueKumarNov 02, 2018This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution.¬†Read more881Aditya KumarAug 13, 2024TESTCASES------------>\n[10,1,2,7,6,1,5]\n8\n[2,5,2,1,2]\n5\n[2, 2, 2, 2, 3, 6, 7]\n9\n[1, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10]\n 25\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\n29\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n30\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\n30\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n 15¬†Read more391James_NagarJul 09, 2024When you consider just consider and move forward, but when you do not consider than do not consider any of it's duplicate, how you make sure it -> just Sort the array and skip all adjacent duplicate elements when you do not consider.¬†Read moreTip5511RafiaDec 01, 2024#TLE 172/176üíî¬†Read more611aman_mnnitOct 01, 2022how to make sure my vector<vector> ans does not contain duplicate values without using set?¬†Read moreAsk Question3119NoahSep 09, 2023Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\nA bit of code for reference:\n       int prev = -1;\n       for (int i = ind; i < cand.Length; i++){\n           if (currSum + cand[i] > targ) break;\n           if (prev == cand[i]) continue;\n           currComb.Add(cand[i]);\n           findComb(cand, targ, currSum + cand[i], currComb, i + 1);\n           currComb.RemoveAt(currComb.Count - 1);\n           prev = cand[i];\n       } ¬†Read moreTip352rakesh_joshiJun 20, 2016Question says\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nEach number in C may only be used once in the combination.\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\nA solution set is:\n[\n[1, 7],\n[1, 2, 5],\n[2, 6],\n[1, 1, 6]\n]\ni am confused of this  condition\nEach number in C may only be used once in the combination.\nas in this example it has the combination [1,1,6]  i.e. repeating 1's\nit is highly appreciable if somebody explains it. Thank you .¬†Read more215lowut02Sep 11, 2023Horrible problem tbh.¬†Read more301123420Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.169Z"
    },
    {
      "id": "leetcode-medium-find-first-and-last-position-of-element-in-sorted-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find First and Last Position of Element in Sorted Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] ans = { -1, -1 };\n        int start = search(nums, target, true);\n        int end = search(nums, target, false);\n        ans[0] = start;\n        ans[1] = end;\n        return ans;\n    }\n\n    static int search(int[] num, int target, boolean firstindex) {\n        int ans = -1;\n        int start = 0;\n        int end = num.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (num[mid] > target) {\n                end = mid - 1;\n            } else if (num[mid] < target) {\n                start = mid + 1;\n            } else {\n                ans = mid;\n                if (firstindex) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "readme": "34. Find First and Last Position of Element in Sorted ArraySolvedMediumTopicsCompaniesGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must¬†write an algorithm with¬†O(log n) runtime complexity.\n\n¬†\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n¬†\nConstraints:\n\n\n\t0 <= nums.length <= 105\n\t-109¬†<= nums[i]¬†<= 109\n\tnums is a non-decreasing array.\n\t-109¬†<= target¬†<= 109\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,851,724/6MAcceptance Rate47.3%TopicsArrayBinary SearchCompaniesSimilar QuestionsFirst Bad VersionEasyPlates Between CandlesMediumFind Target Indices After Sorting ArrayEasyDiscussion (312)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestSatvik ShrivastavaJul 14, 2023After attempting this binary search is running through my veins.¬†Read more36111Tasneem AyhamOct 09, 2023Guys, just for better experience to our fellow LeetCoders, if you find a problem that's ranked medium/hard and you think it should be levelled down, please refrain from writing it in the discussion section as that would demoralize our brothers/sisters. Remember, we were all in their place once!!\nThank you for your understanding!¬†Read more4662Joe NgJan 16, 2022I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code.¬†Read more17114Moonbeam8773Apr 17, 2023I'm sorry. What is \"sorted in non-decreasing order\"? Isn't that just sorted in ascending order?¬†Read more18614PrishaOct 09, 2023When you first encounter this question, your initial instinct might be to employ a simple O(N) solution, where you traverse the array to locate both the first and last positions of the target element. After all, it seems like a straightforward approach, right? ü§î\nHowever, here's where the plot thickens!\nGiven that the array is sorted, why not leverage this fact to your advantage and craft a logarithmic solution instead?  The term \"sorted\" practically whispers to you, suggesting the use of binary search. But how exactly do you wield this powerful technique?\nü§î Ah, here's the twist! The main challenge arises when the element you're looking for equals nums[mid]. Is it the first occurrence or the last? ü§∑‚Äç‚ôÄÔ∏è That's the million-dollar question right there.\n‚ú® Now, here comes the magic trick!\nYou don't just use one binary search; you utilize two of them. ü™Ñ Yes, you heard that right!\nOne binary search is dedicated to finding the lower bound, and the other to discover the upper bound.\nüéØ And just like that, you've transformed a seemingly complex problem into an elegant, efficient solution. Ta-da! üéâ‚ú®üí´¬†Read more2337mstuebsOct 09, 2023Don't submit code that is not thoroughly tested. Make sure to have additional test cases, like\n[]\n42\n[7,8,8,8,8,8,8,8,8,8,8,9]\n7\n[7,8,8,8,8,8,8,8,8,8,8,9]\n8\n[7,8,8,8,8,8,8,8,8,8,8,9]\n10\n[1,2,2,2,2,3,4,5,5,5,5,6,7,8,9,10,11,12,12,12,12,12,13]\n2\n[-999985131,-999953607,-999953607,-999915742,-999883817,-999849817,-999822901,-999815377,-999810801,-68594,-49967,20394,114012,999969829,999973689,999975494]\n-999953607\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/generated/34_Find_First_and_Last_Position_of_Element_in_Sorted_Array.txt¬†Read more616heijinganghuashengNov 16, 2013If the elements of the whole array is the same as the target, can we do it in a O(logn) time?¬†Read more6013M Mahbubul AlamJan 19, 2023At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid.¬†Read moreTip847WizelDec 07, 2022Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?¬†Read more349Shubham JhaNov 22, 2022previous UI was much handy¬†Read more231123432Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-26T20:42:11.170Z"
    },
    {
      "id": "leetcode-medium-group-anagrams",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Group Anagrams",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> result = new ArrayList<>();\n        boolean[] visited = new boolean[strs.length];\n\n        for (int i = 0; i < strs.length; i++) {\n            if (visited[i]) continue;\n\n            List<String> group = new ArrayList<>();\n            group.add(strs[i]);\n            visited[i] = true;\n\n            for (int j = i + 1; j < strs.length; j++) {\n                if (!visited[j] && isAnagram(strs[i], strs[j])) {\n                    group.add(strs[j]);\n                    visited[j] = true;\n                }\n            }\n\n            result.add(group);\n        }\n\n        return result;\n    }\n\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n\n        char[] originalArr = s.toCharArray();\n        char[] modifiedArr = t.toCharArray();\n        Arrays.sort(originalArr);\n        Arrays.sort(modifiedArr);\n\n        return Arrays.equals(originalArr, modifiedArr);\n    }\n}",
        "readme": "49. Group AnagramsSolvedMediumTopicsCompaniesGiven an array of strings strs, group the anagrams together. You can return the answer in any order.\n\n¬†\nExample 1:\n\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n\n\n\tThere is no string in strs that can be rearranged to form \"bat\".\n\tThe strings \"nat\" and \"tan\" are anagrams as they can be rearranged to form each other.\n\tThe strings \"ate\", \"eat\", and \"tea\" are anagrams as they can be rearranged to form each other.\n\n\n\nExample 2:\n\n\nInput: strs = [\"\"]\n\nOutput: [[\"\"]]\n\n\nExample 3:\n\n\nInput: strs = [\"a\"]\n\nOutput: [[\"a\"]]\n\n\n¬†\nConstraints:\n\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted4,045,741/5.7MAcceptance Rate71.3%TopicsArrayHash TableStringSortingCompaniesSimilar QuestionsValid AnagramEasyGroup Shifted StringsMediumFind Resultant Array After Removing AnagramsEasyCount AnagramsHardDiscussion (336)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestHandsomeJensJan 24, 2024Just wanna give props to myself. This was my first medium :)¬†Read more53814NikitaMar 23, 2023 An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nInput:\nstrs = [\"\",\"\"]\nExpected:\n[[\"\",\"\"]]\nWhere are the letters or words?¬†Read moreAsk Question1968DIVITE DINESHFeb 06, 2024Finally can solve this after revisiting 5 times in 6 months.\nThis journey is going incredibly well. üöÄ¬†Read more1461Sawan KushwahOct 01, 2023Approach\ntake out string\nchar array\nsort it\nconvert to string\nuse this string as a key\nthen push all the related element to key¬†Read more17921Freeze FrancisAug 10, 2021This question was part of interview rounds of Amazon.\nFor folks preparing for FAANG interview please read my interview experience.\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b¬†Read more1403An-Wen DengFeb 06, 2024Hash table must be used, because this is a strings' question.\nOne tip:  strings are anagrams <=> same string after sorting. No need for frequency count unless the string is super long.\nHave a nice day!¬†Read more403Bohdan PozharskyiNov 02, 2013What does it mean \"return all groups\"? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?¬†Read more1134MrLebovskySep 01, 2023It says: \" You can return the answer in any order\", but console result is:\nOutput\n[[\"ddddddddddg\",\"dgggggggggg\"]]\nExpected\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\nWhy?¬†Read more468Mahdy KhayyamianFeb 01, 2015Why the output is list and not a list of list. What If there are multiple groups of anagrams?¬†Read more393SamMy89Nov 04, 2014I found nice solution in Java in the internet, and it worked. However, I really don't understand the question. It says\n\nreturn all groups of strings that are anagrams.\n\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need List<List<String>>. But in the problem description the method signature is given by List<String>. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?¬†Read more176123434Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "# Group Anagrams\n\n          **Summary:** The algorithm uses a boolean array to track visited strings and an ArrayList of ArrayLists to store the grouped anagrams. It iterates through the input string array, checking for unvisited strings. For each unvisited string, it forms a group of anagrams by comparing it with the remaining strings using a helper function 'isAnagram', which sorts the characters of two strings and compares them for equality. Finally, it adds the group to the result list.\n\n          - Time Complexity: O(NKlogK), where N is the number of strings and K is the maximum length of a string. This is because sorting each string takes O(KlogK) time, and the algorithm iterates through all strings and pairs of strings. The outer loop runs N times, and the nested loop runs at most N times.  The `isAnagram` function dominates the runtime complexity.\n          - Space Complexity: O(NK), where N is the number of strings and K is the maximum length of a string. This is because in the worst case, all strings could be anagrams of each other, resulting in a list of lists that has approximately NK characters in total. The space used by the `visited` array is O(N), which is dominated by the space used to store the results."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.171Z"
    },
    {
      "id": "leetcode-medium-longest-palindromic-substring",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Palindromic Substring",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        if (n < 2)\n            return s;\n\n        // Transform input string with separators to handle even palindromes\n        char[] t = new char[2 * n + 3];\n        t[0] = '^';\n        for (int i = 0; i < n; i++) {\n            t[2 * i + 1] = '#';\n            t[2 * i + 2] = s.charAt(i);\n        }\n        t[2 * n + 1] = '#';\n        t[2 * n + 2] = '$';\n\n        int[] p = new int[t.length];\n        int center = 0, right = 0;\n        int maxLen = 0, centerIndex = 0;\n\n        for (int i = 1; i < t.length - 1; i++) {\n            int mirror = 2 * center - i;\n\n            if (i < right)\n                p[i] = Math.min(right - i, p[mirror]);\n\n            // expand around i\n            while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) {\n                p[i]++;\n            }\n\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n\n            if (p[i] > maxLen) {\n                maxLen = p[i];\n                centerIndex = i;\n            }\n        }\n\n        int start = (centerIndex - maxLen) / 2;\n        return s.substring(start, start + maxLen);\n    }\n}",
        "readme": "5. Longest Palindromic SubstringSolvedMediumTopicsCompaniesHintGiven a string s, return the longest palindromic substring in s.\n\n¬†\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n¬†\nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted4,092,056/11.3MAcceptance Rate36.3%TopicsTwo PointersStringDynamic ProgrammingCompaniesHint 1How can we reuse a previously computed palindrome to compute a larger palindrome?Hint 2If ‚Äúaba‚Äù is a palindrome, is ‚Äúxabax‚Äù a palindrome? Similarly is ‚Äúxabay‚Äù a palindrome?Hint 3Complexity based hint:\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.Similar QuestionsShortest PalindromeHardPalindrome PermutationEasyPalindrome PairsHardLongest Palindromic SubsequenceMediumPalindromic SubstringsMediumMaximum Number of Non-overlapping Palindrome SubstringsHardDiscussion (496)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestZenMasterVNov 05, 2022Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills\n\" Please don't post any solutions in this discussion tab\"\nIt's almost the rule to find the exact opposite for the discussion of every question. I don't want to see your damned solution!¬†Read more1.3K13Akhil ChauhanOct 27, 2023More like longest palindromic nightmare¬†Read more2191SwetNov 04, 2022It took me an hour to solve this even though it's not that difficult but anyhow came to the conclusion that I need to do more practice.¬†Read more1273sanemdeepakJan 16, 2019For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?¬†Read more17720Neetika BansalJun 04, 2014From the leetcode blog, one of the methods of solving this is:\nA common mistake:\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\nReverse S and become S‚Äô. Find the longest common substring between S and S‚Äô, which must also be the longest palindromic substring.\nThis seemed to work, let‚Äôs see some examples below.\nFor example,\nS = ‚Äúcaba‚Äù, S‚Äô = ‚Äúabac‚Äù.\nThe longest common substring between S and S‚Äô is ‚Äúaba‚Äù, which is the answer.\nLet‚Äôs try another example:\nS = ‚Äúabacdfgdcaba‚Äù, S‚Äô = ‚Äúabacdgfdcaba‚Äù.\nThe longest common substring between S and S‚Äô is ‚Äúabacd‚Äù. Clearly, this is not a valid palindrome.\nWe could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring‚Äôs indices are the same as the reversed substring‚Äôs original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.\nIs this part correct?\nexample string: abcxycba\nreverse string:  abcxycba\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?¬†Read more949napoleonNov 08, 2013My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?¬†Read more10313Tomas SandvenApr 25, 2023I'm getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\ns =\nDid I break it?¬†Read moreFeedback47884danieNov 14, 2016I submitted my solution, and received a Time Limit Exceeded on this test case:\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\n\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug?\n¬†Read more4410miklerAug 25, 2017So I think I finally understood logic of test creators.\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG.\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\nif s == s[::-1]: return s¬†Read more254AlgoEngineJun 17, 2023Visualization of \"Expand from Centers\" solution:\n¬†Read more231123450Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "# Longest Palindromic Substring\n\n          **Summary:** The algorithm uses Manacher's algorithm to find the longest palindromic substring.  It employs a character array `t` to preprocess the input string `s`, adding special characters to handle even-length palindromes efficiently. An integer array `p` stores the lengths of palindromes centered at each position in `t`. The algorithm iteratively expands around each center, updating `p`, `center`, and `right` to track the longest palindrome found so far.\n\n          - Time Complexity: O(n) because the main loop iterates through the transformed string `t` once, which is linearly proportional to the length of the original string `s`.  The inner `while` loop's total iterations are also bounded by O(n).\n          - Space Complexity: O(n) because the algorithm uses an array `t` and an array `p`, both of which are linearly proportional to the length of the transformed string, which is O(n) compared to the original string."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.172Z"
    },
    {
      "id": "leetcode-medium-pow-x--n-",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Pow(x, n)",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double myPow(double x, int n) {\n        return Math.pow(x,n);\n    }\n}",
        "readme": "50. Pow(x, n)SolvedMediumTopicsCompaniesImplement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\n¬†\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\n\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\n\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\n¬†\nConstraints:\n\n\n\t-100.0 < x < 100.0\n\t-231 <= n <= 231-1\n\tn is an integer.\n\tEither x is not zero or n > 0.\n\t-104 <= xn <= 104\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,366,908/6.3MAcceptance Rate37.4%TopicsMathRecursionCompaniesSimilar QuestionsSqrt(x)EasySuper PowMediumCount Collisions of Monkeys on a PolygonMediumDiscussion (499)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestTyler MatchettFeb 16, 2023Here is a test case made by someone who was in a bad mood\nx=-1\nn=2147483647¬†Read moreTip59113mrkanesirFeb 18, 2023how am i supposed to NOT get stack overflow with n=2147483647 ...¬†Read more35719Soumyajit Dey SarkarJul 24, 2023return pow(x,n);\nBeats 100% of the Solution :)\nI have successfully unlocked my clown outfit.¬†Read more4249Linearly IndependentApr 07, 2022return x**n¬†Read more45326SylvexMar 18, 2023x =\n2.00000\nn =\n-2147483648\nWhat even is the point of this edge case???¬†Read more18825olooneyJul 06, 2018This is the 37th problem I've solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there's certainly some shared negativity out there.\nPersonally, I didn't enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn't account for the case when n is -2^31 and x is exactly -1.0! There's no way we'd hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail every single corner case. Perhaps that frustration is limited to C/C++? Or there's a different algorithm that more naturally accounts for these edge cases?\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site?¬†Read more27411Rishabh MishraJul 24, 2023Someone just hates society\nn = INT_MIN & x = 1.0000000000001 wtf !!¬†Read more831shadowfax_Jan 31, 2022just has the onsite and the interviewer tdidn't want the recursive version but wanted the fast one with no recursion.¬†Read more725natitatiApr 15, 2023Is there something broken about testcase 305?¬†Read more424HitroMar 19, 2019I'm wondering why you guys are not using builtin Math.pow() method??\nPlease give me some insight.\nThank you :)¬†Read more618123450Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "Pow(x, n)\n\n          - Summary: The Java code uses the built-in Math.pow() function to compute x raised to the power of n.  No additional data structures are used. The function directly calls the Math.pow() method, which internally uses a highly optimized algorithm (likely involving logarithms and bit manipulation) to calculate the result. The result, a double-precision floating-point number representing x^n, is then returned.\n\n          - Time Complexity: O(1) - The Math.pow() function in Java has a constant time complexity because it's implemented using highly optimized native code.\n          - Space Complexity: O(1) - The function uses constant extra space, regardless of the input values of x and n."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.173Z"
    },
    {
      "id": "leetcode-hard-n-queens-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "N-Queens II",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        // sets to track attacked columns and diagonals\n        unordered_set<int> cols, diag1, diag2;\n        int count = 0;\n\n        function<void(int)> backtrack = [&](int row) {\n            if (row == n) {\n                count++;\n                return;\n            }\n\n            for (int col = 0; col < n; col++) {\n                if (cols.count(col) || diag1.count(row - col) ||\n                    diag2.count(row + col))\n                    continue;\n\n                // place queen\n                cols.insert(col);\n                diag1.insert(row - col);\n                diag2.insert(row + col);\n\n                backtrack(row + 1);\n\n                // remove queen (backtrack)\n                cols.erase(col);\n                diag1.erase(row - col);\n                diag2.erase(row + col);\n            }\n        };\n\n        backtrack(0);\n        return count;\n    }\n};",
        "readme": "52. N-Queens IISolvedHardTopicsCompaniesThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return the number of distinct solutions to the¬†n-queens puzzle.\n\n¬†\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\n¬†\nConstraints:\n\n\n\t1 <= n <= 9\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted520,328/674KAcceptance Rate77.2%TopicsBacktrackingCompaniesSimilar QuestionsN-QueensHardDiscussion (94)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestNo comments yet.123410Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "# N-Queens II\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:42:11.174Z"
    }
  ]
}