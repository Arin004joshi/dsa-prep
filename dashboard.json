{
  "metadata": {
    "totalProblems": 35,
    "lastUpdated": "2025-09-27T08:57:18.939Z",
    "breakdown": {
      "Codechef": {
        "total": 4,
        "Easy": 1,
        "Medium": 3,
        "Hard": 0
      },
      "Gfg": {
        "total": 12,
        "Easy": 8,
        "Medium": 3,
        "Hard": 1
      },
      "Leetcode": {
        "total": 9,
        "Easy": 3,
        "Medium": 5,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 10,
        "Easy": 0,
        "Medium": 10,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "codechef-easy-saving-taxes",
      "platform": "Codechef",
      "difficulty": "Easy",
      "problemName": "Saving Taxes",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    \r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        long long X, Y;\r\n        cin >> X >> Y;\r\n        cout << (X - Y) << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Saving Taxes\n\nIn Chefland, everyone who earns strictly more than \nùëå\nY rupees per year, has to pay a tax to Chef. Chef has allowed a special scheme where you can invest any amount of money and claim exemption for it.\n\nYou have earned \nùëã\nX \n(\nùëã\n>\nùëå\n)\n(X>Y) rupees this year. Find the minimum amount of money you have to invest so that you don't have to pay taxes this year.\n\nInput Format\nThe first line of input will contain a single integer \nùëá\nT, denoting the number of test cases.\nEach test case consists of a single line of input consisting of two space separated integers \nùëã\nX and \nùëå\nY denoting the amount you earned and the amount above which you will have to pay taxes.\nOutput Format\n\nFor each test case, output a single integer, denoting the minimum amount you need to invest.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n100\n1‚â§T‚â§100\n1\n‚â§\nùëå\n<\nùëã\n‚â§\n100\n1‚â§Y<X‚â§100\nSample 1:\nInput\nOutput\n4\n4 2\n8 7\n5 1\n2 1\n\n2\n1\n4\n1\n\nExplanation:\n\nTest case \n1\n1: The amount above which you will have to pay taxes is \n2\n2. Since you earn \n4\n4 rupees, you need to invest at least \n2\n2 rupees. After investing \n2\n2 rupees, you will remain with an effective income \n4\n‚àí\n2\n=\n2\n4‚àí2=2 rupees which will not be taxed.\n\nTest case \n2\n2: The amount above which you will have to pay taxes is \n7\n7. Since you earn \n8\n8 rupees, you need to invest at least \n1\n1 rupees.\n\nTest case \n3\n3: The amount above which you will have to pay taxes is \n1\n1. Since you earn \n5\n5 rupees, you need to invest at least \n4\n4 rupees.\n\nTest case \n4\n4: The amount above which you will have to pay taxes is \n1\n1. Since you earn \n2\n2 rupees, you need to invest at least \n1\n1 rupees.",
        "notes": "Difference Calculation\n\n          - Summary: The code takes an integer T as input, representing the number of test cases. For each test case, it reads two long long integers, X and Y, and then outputs the difference between X and Y (X - Y). No data structures beyond built-in types are used. The code reads input, performs a simple arithmetic operation, and prints the result for each test case.\n\n          - Time Complexity: O(T), where T is the number of test cases.  The time complexity is linear because the code iterates through each test case once, performing a constant amount of work for each case.\n          - Space Complexity: O(1). The space used is constant because the code only stores a fixed number of variables regardless of the input size. The input values themselves are not stored in any sizable data structure."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:43:18.000Z"
    },
    {
      "id": "codechef-medium-bitwise-tuples",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Bitwise Tuples",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst long long MOD = 1e9 + 7;\r\n\r\n// fast exponentiation\r\nlong long modpow(long long base, long long exp, long long mod) {\r\n    long long result = 1;\r\n    base %= mod;\r\n    while (exp > 0) {\r\n        if (exp & 1) result = (result * base) % mod;\r\n        base = (base * base) % mod;\r\n        exp >>= 1;\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    \r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        long long N, M;\r\n        cin >> N >> M;\r\n        \r\n        long long base = (modpow(2, N, MOD) - 1 + MOD) % MOD;\r\n        long long ans = modpow(base, M, MOD);\r\n        \r\n        cout << ans << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Bitwise Tuples\nRead problem statements in Vietnamese,\n\nBengali, Mandarin Chinese, and Russian as well.\n\nChef has two numbers \nùëÅ\nN and \nùëÄ\nM. Help Chef to find number of integer \nùëÅ\nN-tuples \n(\nùê¥\n1\n,\nùê¥\n2\n,\n‚Ä¶\n,\nùê¥\nùëÅ\n)\n(A\n1\n\t‚Äã\n\n,A\n2\n\t‚Äã\n\n,‚Ä¶,A\nN\n\t‚Äã\n\n) such that \n0\n‚â§\nùê¥\n1\n,\nùê¥\n2\n,\n‚Ä¶\n,\nùê¥\nùëÅ\n‚â§\n2\nùëÄ\n‚àí\n1\n0‚â§A\n1\n\t‚Äã\n\n,A\n2\n\t‚Äã\n\n,‚Ä¶,A\nN\n\t‚Äã\n\n‚â§2\nM\n‚àí1 and \nùê¥\n1\n&\nùê¥\n2\n&\n‚Ä¶\n&\nùê¥\nùëÅ\n=\n0\nA\n1\n\t‚Äã\n\n&A\n2\n\t‚Äã\n\n&‚Ä¶&A\nN\n\t‚Äã\n\n=0, where \n&\n& denotes the bitwise AND operator.\n\nSince the number of tuples can be large, output it modulo \n10\n9\n+\n7\n10\n9\n+7.\n\nInput\nThe first line contains a single integer \nùëá\nT denoting the number of test cases. The description of \nùëá\nT test cases follows.\nThe first and only line of each test case contains two integers \nùëÅ\nN and \nùëÄ\nM.\nOutput\n\nFor each test case, output in a single line the answer to the problem modulo \n10\n9\n+\n7\n10\n9\n+7.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n10\n5\n1‚â§T‚â§10\n5\n1\n‚â§\nùëÅ\n,\nùëÄ\n‚â§\n10\n6\n1‚â§N,M‚â§10\n6\n\n###Subtasks Subtask #1 (100 points): original constraints\n\nSample 1:\nInput\nOutput\n4\n1 2\n2 2\n4 2\n8 4\n1\n9\n225\n228250597\nExplanation:\n\nTest Case \n1\n1: The only possible tuple is \n(\n0\n)\n(0).\n\nTest Case \n2\n2: The tuples are \n(\n0\n,\n0\n)\n(0,0), \n(\n0\n,\n1\n)\n(0,1), \n(\n0\n,\n2\n)\n(0,2), \n(\n0\n,\n3\n)\n(0,3), \n(\n1\n,\n0\n)\n(1,0), \n(\n2\n,\n0\n)\n(2,0), \n(\n3\n,\n0\n)\n(3,0), \n(\n1\n,\n2\n)\n(1,2), \n(\n2\n,\n1\n)\n(2,1).",
        "notes": "# Bitwise Tuples\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T18:42:48.000Z"
    },
    {
      "id": "codechef-medium-plusle-and-minun-on-array",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Plusle and Minun on Array",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        int N;\r\n        cin >> N;\r\n        vector<long long> A(N+1);\r\n        for (int i = 1; i <= N; i++) cin >> A[i];\r\n\r\n        long long base = 0;\r\n        long long minOdd = LLONG_MAX, maxEven = LLONG_MIN;\r\n\r\n        for (int i = 1; i <= N; i++) {\r\n            long long val = abs(A[i]);\r\n            if (i % 2 == 1) { // odd index -> positive\r\n                base += val;\r\n                minOdd = min(minOdd, val);\r\n            } else { // even index -> negative\r\n                base -= val;\r\n                maxEven = max(maxEven, val);\r\n            }\r\n        }\r\n\r\n        long long delta = 0;\r\n        if (minOdd != LLONG_MAX && maxEven != LLONG_MIN) {\r\n            delta = max(0LL, (maxEven - minOdd) * 2);\r\n        }\r\n\r\n        cout << base + delta << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "Plusle and Minun on Array\n\nChef has an array \nùê¥\nA of length \nùëÅ\nN. He defines the alternating sum of the array as:\n\nùëÜ\n=\n‚à£\nùê¥\n1\n‚à£\n‚àí\n‚à£\nùê¥\n2\n‚à£\n+\n‚à£\nùê¥\n3\n‚à£\n‚àí\n‚à£\nùê¥\n4\n‚à£\n+\n‚Ä¶\n(\n‚àí\n1\n)\nùëÅ\n‚àí\n1\n‚ãÖ\n‚à£\nùê¥\nùëÅ\n‚à£\nS=‚à£A\n1\n\t‚Äã\n\n‚à£‚àí‚à£A\n2\n\t‚Äã\n\n‚à£+‚à£A\n3\n\t‚Äã\n\n‚à£‚àí‚à£A\n4\n\t‚Äã\n\n‚à£+‚Ä¶(‚àí1)\nN‚àí1\n‚ãÖ‚à£A\nN\n\t‚Äã\n\n‚à£\n\nChef is allowed to perform the following operation on the array at most once:\n\nChoose two indices \nùëñ\ni and \nùëó\nj \n(\n1\n‚â§\nùëñ\n<\nùëó\n‚â§\nùëÅ\n)\n(1‚â§i<j‚â§N) and swap the elements \nùê¥\nùëñ\nA\ni\n\t‚Äã\n\n and \nùê¥\nùëó\nA\nj\n\t‚Äã\n\n.\n\nFind the maximum alternating sum Chef can achieve by performing the operation at most once.\n\nNote: \n‚à£\nùëã\n‚à£\n‚à£X‚à£ denotes the absolute value of \nùëã\nX. For example, \n‚à£\n‚àí\n4\n‚à£\n=\n4\n‚à£‚àí4‚à£=4 and \n‚à£\n7\n‚à£\n=\n7\n‚à£7‚à£=7.\n\nInput Format\nThe first line will contain \nùëá\nT - the number of test cases. Then the test cases follow.\nFirst line of each test case contains a single integer \nùëÅ\nN - size of the array \nùê¥\nA.\nSecond line of each test case contains \nùëÅ\nN space separated integers - denoting the elements of array \nùê¥\nA.\nOutput Format\n\nFor each testcase, output in a single line, the maximum alternating sum Chef can obtain by performing the operation at most once.\n\nConstraints\n1\n‚â§\nùëá\n‚â§\n10\n5\n1‚â§T‚â§10\n5\n2\n‚â§\nùëÅ\n‚â§\n10\n5\n2‚â§N‚â§10\n5\n‚àí\n10\n9\n‚â§\nùê¥\nùëñ\n‚â§\n10\n9\n‚àí10\n9\n‚â§A\ni\n\t‚Äã\n\n‚â§10\n9\nSum of \nùëÅ\nN over all test cases does not exceed \n2\n‚ãÖ\n10\n5\n2‚ãÖ10\n5\n.\nSample 1:\nInput\nOutput\n2\n2\n10 -10\n7\n-3 -2 -1 0 1 2 3\n\n0\n6\n\nExplanation:\n\nTest Case \n1\n1: One optimal way is to perform no operations. Thus the alternating sum is \n‚à£\n10\n‚à£\n‚àí\n‚à£\n‚àí\n10\n‚à£\n=\n10\n‚àí\n10\n=\n0\n‚à£10‚à£‚àí‚à£‚àí10‚à£=10‚àí10=0.\n\nTest Case \n2\n2: One optimal way is to choose \nùëñ\n=\n2\ni=2 and \nùëó\n=\n5\nj=5. After swapping, the array is \n[\n‚àí\n3\n,\n1\n,\n‚àí\n1\n,\n0\n,\n‚àí\n2\n,\n2\n,\n3\n]\n[‚àí3,1,‚àí1,0,‚àí2,2,3]. The alternating sum in this case is \n‚à£\n‚àí\n3\n‚à£\n‚àí\n‚à£\n1\n‚à£\n+\n‚à£\n‚àí\n1\n‚à£\n‚àí\n‚à£\n0\n‚à£\n+\n‚à£\n‚àí\n2\n‚à£\n‚àí\n‚à£\n2\n‚à£\n+\n‚à£\n3\n‚à£\n=\n6\n‚à£‚àí3‚à£‚àí‚à£1‚à£+‚à£‚àí1‚à£‚àí‚à£0‚à£+‚à£‚àí2‚à£‚àí‚à£2‚à£+‚à£3‚à£=6.",
        "notes": "# Plusle and Minun on Array\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T18:46:40.000Z"
    },
    {
      "id": "codechef-medium-reversing-directions",
      "platform": "Codechef",
      "difficulty": "Medium",
      "problemName": "Reversing directions",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        int N;\r\n        cin >> N;\r\n        cin.ignore(); // clear newline\r\n\r\n        vector<string> instr(N);\r\n        for (int i = 0; i < N; i++) {\r\n            getline(cin, instr[i]);\r\n        }\r\n\r\n        // Reverse directions\r\n        string prevRoad = \"\";\r\n        for (int i = N - 1; i >= 0; i--) {\r\n            string s = instr[i];\r\n            if (i == N - 1) {\r\n                // Last instruction in original becomes \"Begin\"\r\n                size_t pos = s.find(\" on \");\r\n                string road = s.substr(pos + 4);\r\n                cout << \"Begin on \" << road << \"\\n\";\r\n                prevRoad = road;\r\n            } else {\r\n                size_t pos = s.find(\" on \");\r\n                string turn = s.substr(0, pos); // \"Left\" or \"Right\" or \"Begin\"\r\n                string road = s.substr(pos + 4);\r\n\r\n                if (turn == \"Left\")\r\n                    cout << \"Right on \" << prevRoad << \"\\n\";\r\n                else if (turn == \"Right\")\r\n                    cout << \"Left on \" << prevRoad << \"\\n\";\r\n                else if (turn == \"Begin\")\r\n                    cout << \"Begin on \" << prevRoad << \"\\n\";\r\n\r\n                prevRoad = road;\r\n            }\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n    return 0;\r\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T10:32:50.000Z"
    },
    {
      "id": "gfg-easy-array-duplicates",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Array Duplicates",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> findDuplicates(vector<int>& arr) {\r\n        vector<int> ans;\r\n        int n = arr.size();\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            int x = abs(arr[i]);\r\n            if (arr[x - 1] < 0) {\r\n                ans.push_back(x);\r\n            } else {\r\n                arr[x - 1] = -arr[x - 1];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};",
        "readme": "Arrays,Data_Structures\n\nArray Duplicates\nDifficulty: EasyAccuracy: 18.95%Submissions: 861K+Points: 2Average Time: 20m\n\nGiven an array arr[] of size n, containing elements from the range 1 to n, and each element appears at most twice, return an array of all the integers that appears twice.\n\nNote: You can return the elements in any order but the driver code will print them in sorted order.\n\nExamples:\n\nInput: arr[] = [2, 3, 1, 2, 3]\nOutput: [2, 3] \nExplanation: 2 and 3 occur more than once in the given array.\nInput: arr[] = [3, 1, 2] \nOutput: []\nExplanation: There is no repeating element in the array, so the output is empty.\n\nConstraints:\n1 ‚â§ n ‚â§¬†106\n1 ‚â§ arr[i] ‚â§ n\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "Array Duplicates\n\n          - Summary: The code utilizes a single array to store the input numbers and identify duplicates. It iterates through the array; for each number, it checks if the corresponding index (number - 1) has a negative value. If negative, the number is already encountered and added to the result vector; otherwise, it negates the value at that index to mark the number as seen. The algorithm leverages the array itself to track seen numbers, avoiding extra space for a hash map.\n\n          - Time Complexity: O(n) because the code iterates through the input array once. Each operation inside the loop takes constant time.\n          - Space Complexity: O(1) in addition to output.  While the input array is modified, the extra space used is constant and does not depend on the input size. The space complexity is dominated by the size of the output vector, which in the worst case can be O(n), if all numbers are duplicates. In reality, though, the output will always be less than n"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-27T08:50:12.000Z"
    },
    {
      "id": "gfg-easy-binary-search",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Binary Search",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int binarysearch(vector<int> &arr, int k) {\r\n        int left = 0, right = arr.size() - 1;\r\n        int ans = -1;   // store index of k if found\r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2;\r\n\r\n            if (arr[mid] == k) {\r\n                ans = mid;       // potential answer\r\n                right = mid - 1; // keep looking left for smaller index\r\n            } \r\n            else if (arr[mid] < k) {\r\n                left = mid + 1;\r\n            } \r\n            else {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};",
        "readme": "Arrays,Searching,Divide and_Conquer,Data_Structures,Algorithms\n\nBinary Search\nDifficulty: EasyAccuracy: 44.32%Submissions: 633K+Points: 2Average Time: 20m\n\nGiven a sorted array arr[] and an integer k, find the position(0-based indexing) at which k is present in the array using binary search. If k doesn't exist in arr[] return -1.¬†\n\nNote: If multiple occurrences are there, please return the smallest index.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4, 5], k = 4\nOutput: 3\nExplanation: 4 appears at index 3.\nInput: arr[] = [11, 22, 33, 44, 55], k = 445\nOutput: -1\nExplanation: 445 is not present.\n\nInput: arr[] = [1, 1, 1, 1, 2], k = 1\nOutput: 0\nExplanation: 1 appears at index 0.\n\nConstraints:\n1 ‚â§ arr.size() ‚â§ 105\n1 ‚â§ arr[i] ‚â§ 106\n1 ‚â§ k ‚â§ 106\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "Binary Search\n\n          - Summary: This code implements a binary search algorithm using a sorted integer array. It initializes pointers 'left' and 'right' to the start and end of the array, respectively.  The algorithm iteratively narrows the search space by comparing the middle element with the target value 'k', updating 'left' or 'right' accordingly.  If 'k' is found, the function returns its index; otherwise, it returns -1.\n\n          - Time Complexity: O(log n) because the search space is halved in each iteration of the while loop.  The number of iterations is proportional to the logarithm base 2 of the array size.\n          - Space Complexity: O(1) because the algorithm uses a constant amount of extra space regardless of the input array size.  Only a few integer variables are used to store indices and the result."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T17:30:27.000Z"
    },
    {
      "id": "gfg-easy-check-for-bst",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Check for BST",
      "language": "cpp",
      "files": {
        "code": "/*\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n*/\n\nclass Solution {\n  public:\n    // Helper function with range limits\n    bool helper(Node* root, long long minVal, long long maxVal) {\n        if (!root) return true;\n\n        if (root->data <= minVal || root->data >= maxVal) {\n            return false;\n        }\n\n        // Left subtree must be < root->data\n        // Right subtree must be > root->data\n        return helper(root->left, minVal, root->data) &&\n               helper(root->right, root->data, maxVal);\n    }\n\n    // Function to check whether a Binary Tree is BST or not.\n    bool isBST(Node* root) {\n        return helper(root, LLONG_MIN, LLONG_MAX);\n    }\n};",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T10:35:59.000Z"
    },
    {
      "id": "gfg-easy-lcm-and-gcd",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "LCM And GCD",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int gcd(int a, int b) {\r\n        while (b != 0) {\r\n            int temp = b;\r\n            b = a % b;\r\n            a = temp;\r\n        }\r\n        return a;\r\n    }\r\n    \r\n    vector<int> lcmAndGcd(int a, int b) {\r\n        int gcd_val = gcd(a, b);\r\n        long long lcm_val = (1LL * a * b) / gcd_val;\r\n        \r\n        vector<int> ans;\r\n        ans.push_back((int)lcm_val);\r\n        ans.push_back(gcd_val);\r\n        return ans;\r\n    }\r\n};",
        "readme": "LCM And GCD\nDifficulty: BasicAccuracy: 37.02%Submissions: 222K+Points: 1\n\nGiven two integers a and b, You have to compute their LCM and GCD and return an array containing their LCM and GCD.\n\nExamples:\n\nInput: a = 5 , b = 10\nOutput: [10, 5]\nExplanation: LCM of 5 and 10 is 10, while their GCD is 5.\nInput: a = 14 , b = 8\nOutput: [56, 2]\nExplanation: LCM of 14 and 8 is 56, while their GCD is 2.\n\nInput: a = 1 , b = 1\nOutput: [1, 1]\nExplanation: LCM of 1 and 1 is 1, while their GCD is 1.\n\nConstraints:\n1 ‚â§ a, b ‚â§ 104\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": "LCM And GCD\n\n          - Summary: The code uses a vector to store the calculated least common multiple (LCM) and greatest common divisor (GCD) of two input integers.  It first calculates the GCD using Euclid's algorithm, iteratively reducing the numbers until the remainder is zero. Then, it calculates the LCM using the formula (a * b) / GCD(a, b), ensuring to use long long to prevent integer overflow. Finally, it stores the LCM and GCD in a vector and returns it.\n\n          - Time Complexity: O(log(min(a, b))) because the GCD function using Euclid's algorithm has a time complexity of O(log(min(a, b))). The remaining operations are constant time.\n          - Space Complexity: O(1) as the algorithm uses a fixed amount of space irrespective of the input size.  The vector used to store the result has a constant size of 2."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:40:35.000Z"
    },
    {
      "id": "gfg-easy-missing-in-array",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Missing in Array",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int missingNum(vector<int>& arr) {\r\n        int n = arr.size() + 1;  // since one number is missing\r\n        long long total = 1LL * n * (n + 1) / 2;  // expected sum\r\n        long long actual = 0;\r\n        for (int x : arr) actual += x;\r\n        return (int)(total - actual);\r\n    }\r\n};",
        "readme": "Missing in Array\nDifficulty: EasyAccuracy: 29.59%Submissions: 1.5MPoints: 2Average Time: 15m\n\nYou are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.\n\n\nConstraints:\n1 ‚â§ arr.size() ‚â§ 106\n1 ‚â§ arr[i] ‚â§ arr.size() + 1\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "# Missing in Array\n\n          **Summary:** This code implements a solution using C++ (12). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T18:33:53.000Z"
    },
    {
      "id": "gfg-easy-print-1-to-n-without-loop",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Print 1 To N Without Loop",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    void printNos(int n) {\r\n        if (n == 0) return;         // base case\r\n        printNos(n - 1);            // recursive call\r\n        cout << n << \" \";           // print after recursion\r\n    }\r\n};",
        "readme": "Print 1 To N Without Loop\nDifficulty: BasicAccuracy: 61.33%Submissions: 322K+Points: 1\n\nYou are given an integer n. You have¬† to print all numbers from 1 to n.\nNote:¬†You must use recursion only, and print all numbers from 1 to n in a single line, separated by spaces.\n\nExamples:\n\n\nInput: n = 10\nOutput: 1 2 3 4 5 6 7 8 9 10\n\nInput: n = 5\nOutput: 1 2 3 4 5\nInput: n = 1\nOutput: 1\n\nConstraints:\n1 ‚â§ n ‚â§ 103\n\nTry more examples\nExpected Complexities\nTopic Tags\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T14:00:52.000Z"
    },
    {
      "id": "gfg-easy-second-largest",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Second Largest",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n public:\r\n  /**\r\n   * Finds the second largest distinct element in the array.\r\n   * Time Complexity: O(n)\r\n   * Space Complexity: O(1)\r\n   */\r\n  int getSecondLargest(std::vector<int>& arr) {\r\n    if (arr.size() < 2) {\r\n      // If the array has less than 2 elements, the second largest doesn't exist.\r\n      return -1;\r\n    }\r\n\r\n    // Initialize largest and secondLargest. Since array elements are positive (>= 1),\r\n    // we can initialize them to -1.\r\n    int largest = -1;\r\n    int secondLargest = -1;\r\n\r\n    for (int num : arr) {\r\n      if (num > largest) {\r\n        // If the current element is greater than the current largest,\r\n        // the old largest becomes the new secondLargest, and the current element\r\n        // becomes the new largest.\r\n        secondLargest = largest;\r\n        largest = num;\r\n      } else if (num < largest && num > secondLargest) {\r\n        // If the current element is smaller than the largest but greater than\r\n        // the current secondLargest, it becomes the new secondLargest.\r\n        // This ensures distinctness: num < largest\r\n        secondLargest = num;\r\n      }\r\n      // If num == largest, we ignore it as we are looking for a distinct second largest.\r\n      // If num <= secondLargest, we also ignore it.\r\n    }\r\n\r\n    // The result is the value stored in secondLargest. If no distinct second largest\r\n    // was found (e.g., all elements are the same, like [10, 10, 10]), it will remain -1.\r\n    return secondLargest;\r\n  }\r\n};",
        "readme": "Arrays,Searching,Data_Structures,Algorithms\n\nSecond Largest\nDifficulty: EasyAccuracy: 26.72%Submissions: 1.3MPoints: 2Average Time: 15m\n\nGiven an array of positive integers arr[], return the second largest element from the array. If the second largest element doesn't exist then return -1.\n\nNote: The second largest element should not be equal to the largest element.\n\nExamples:\n\nInput: arr[] = [12, 35, 1, 10, 34, 1]\nOutput: 34\nExplanation: The largest element of the array is 35 and the second largest element is 34.\nInput: arr[] = [10, 5, 10]\nOutput: 5\nExplanation: The largest element of the array is 10 and the second largest element is 5.\nInput: arr[] = [10, 10, 10]\nOutput: -1\nExplanation: The largest element of the array is 10 and the second largest element does not exist.\n\nConstraints:\n2 ‚â§ arr.size() ‚â§ 105\n1 ‚â§ arr[i]¬†‚â§ 105\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-09-26T17:54:12.000Z"
    },
    {
      "id": "gfg-easy-string-rotated-by-2-places",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "String Rotated by 2 Places",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    bool isRotated(string& s1, string& s2) {\r\n        if (s1.length() != s2.length()) return false;\r\n        if (s1.length() < 2) return s1 == s2;\r\n        \r\n        // Left rotation by 2\r\n        string leftRot = s1.substr(2) + s1.substr(0, 2);\r\n        \r\n        // Right rotation by 2\r\n        string rightRot = s1.substr(s1.size() - 2) + s1.substr(0, s1.size() - 2);\r\n        \r\n        return (s2 == leftRot || s2 == rightRot);\r\n    }\r\n};",
        "readme": "String Rotated by 2 Places\nDifficulty: EasyAccuracy: 32.7%Submissions: 253K+Points: 2Average Time: 20m\n\nGiven two strings s1 and s2. Return true if the string s2 can be obtained by rotating¬†(in any direction) string s1 by exactly 2 places, otherwise, false.\n\nNote: Both rotations should be performed in same direction chosen initially.\n\nExamples:\n\nInput: s1 = \"amazon\", s2 = \"azonam\"\nOutput: true\nExplanation: \"amazon\" can be rotated anti-clockwise by two places, which will make it as \"azonam\".\n\nInput: s1 = \"geeksforgeeks\", s2 = \"geeksgeeksfor\"\nOutput: false\nExplanation: If we rotate \"geeksforgeeks\" by two place in any direction, we won't get \"geeksgeeksfor\".\n\nInput: s1 = \"ab\", s2 = \"ab\"\nOutput: true\nExplanation: If we rotate \"ab\" by two place in any direction, we always get \"ab\".\n\nConstraints:\n1 ‚â§ s1.length, s2.length ‚â§ 105\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T14:03:54.000Z"
    },
    {
      "id": "gfg-medium-bellman-ford",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Bellman-Ford",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> bellmanFord(int V, vector<vector<int>>& edges, int src) {\r\n        const int INF = 100000000;  // must be exactly 1e8\r\n        vector<int> dist(V, INF);\r\n        dist[src] = 0;\r\n        \r\n        for (int i = 1; i <= V - 1; i++) {\r\n            bool changed = false;\r\n            for (auto &e : edges) {\r\n                int u = e[0], v = e[1], w = e[2];\r\n                if (dist[u] != INF && dist[u] + w < dist[v]) {\r\n                    dist[v] = dist[u] + w;\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed) break;\r\n        }\r\n        \r\n        for (auto &e : edges) {\r\n            int u = e[0], v = e[1], w = e[2];\r\n            if (dist[u] != INF && dist[u] + w < dist[v]) {\r\n                return {-1};\r\n            }\r\n        }\r\n        \r\n        return dist;\r\n    }\r\n};",
        "readme": "Bellman-Ford\nDifficulty: MediumAccuracy: 48.11%Submissions: 227K+Points: 4Average Time: 25m\n\nGiven an weighted graph with V vertices numbered from 0 to V-1 and E edges, represented by a 2d array edges[][], where edges[i] = [u, v, w] represents a direct edge from node u to v having w edge weight. You are also given a source vertex src.\n\nYour task is to compute the shortest distances from the source to all other vertices. If a vertex is unreachable from the source, its distance should be marked as 108. Additionally, if the graph contains a negative weight cycle, return [-1] to indicate that shortest paths cannot be reliably computed.\n\nExamples:\n\nInput: V = 5, edges[][] = [[1, 3, 2], [4, 3, -1], [2, 4, 1], [1, 2, 1], [0, 1, 5]], src = 0\n\nOutput: [0, 5, 6, 6, 7]\nExplanation: Shortest Paths:\nFor 0 to 1 minimum distance will be 5. By following path 0 ‚Üí 1\nFor 0 to 2 minimum distance will be 6. By following path 0 ‚Üí 1  ‚Üí 2\nFor 0 to 3 minimum distance will be 6. By following path 0 ‚Üí 1  ‚Üí 2 ‚Üí 4 ‚Üí 3 \nFor 0 to 4 minimum distance will be 7. By following path 0 ‚Üí 1  ‚Üí 2 ‚Üí 4\n\nInput: V = 4, edges[][] = [[0, 1, 4], [1, 2, -6], [2, 3, 5], [3, 1, -2]], src = 0\n\nOutput: [-1]\nExplanation: The graph contains a negative weight cycle formed by the path 1 ‚Üí 2 ‚Üí 3 ‚Üí 1, where the total weight of the cycle is negative.\n\n\nConstraints:\n1 ‚â§ V ‚â§ 100\n1 ‚â§ E = edges.size() ‚â§ V*(V-1)\n-1000 ‚â§ w ‚â§ 1000\n0 ‚â§ src < V\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T14:07:04.000Z"
    },
    {
      "id": "gfg-medium-indexes-of-subarray-sum",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Indexes of Subarray Sum",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> subarraySum(vector<int> &arr, int target) {\r\n        int n = arr.size();\r\n        int start = 0;\r\n        long long sum = 0; // use long long to avoid overflow\r\n\r\n        for (int end = 0; end < n; end++) {\r\n            sum += arr[end];\r\n\r\n            // shrink the window if sum exceeds target\r\n            while (sum > target && start <= end) {\r\n                sum -= arr[start];\r\n                start++;\r\n            }\r\n\r\n            // check if sum matches\r\n            if (sum == target) {\r\n                return {start + 1, end + 1}; // 1-based indices\r\n            }\r\n        }\r\n        return {-1}; // if no subarray found\r\n    }\r\n};",
        "readme": "Algorithms,Arrays,Data_Structuresprefix-sum,Searchingsliding-window\n\nIndexes of Subarray Sum\nDifficulty: MediumAccuracy: 16.5%Submissions: 1.8MPoints: 4Average Time: 20m\n\nGiven an array arr[] containing only non-negative integers, your task is to find a continuous subarray (a contiguous sequence of elements) whose sum equals a specified value target. You need to return the 1-based indices of the leftmost and rightmost elements of this subarray. You need to find the first subarray whose sum is equal to the target.\n\nNote: If no such array is possible then, return [-1].\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 7, 5], target = 12\nOutput: [2, 4]\nExplanation: The sum of elements from 2nd to 4th position is 12.\nInput: arr[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 15\nOutput: [1, 5]\nExplanation: The sum of elements from 1st to 5th position is 15.\n\nInput: arr[] = [5, 3, 4], target = 2\nOutput: [-1]\nExplanation: There is no subarray with sum 2.\n\nConstraints:\n1 <= arr.size()<= 106\n0 <= arr[i] <= 103\n0 <=¬†target <= 109\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "Sliding Window Subarray Sum (Positive Integers Assumption)\n\n          - Summary: This solution uses the Two-Pointer/Sliding Window technique, employing two integer pointers ('start' and 'end') and a long long variable 'sum' to track the current window's sum. The 'end' pointer expands the window by adding elements, and if the 'sum' exceeds 'target', the 'start' pointer contracts the window by subtracting elements until the sum is manageable or the window collapses. If 'sum' equals 'target', it immediately returns the 1-based indices of the window; otherwise, it returns {-1} after checking all possibilities.\n\n          - Time Complexity: O(n) because both the 'start' and 'end' pointers traverse the array at most once, resulting in linear time complexity.\n          - Space Complexity: O(1) because the solution only uses a fixed number of extra variables ('n', 'start', 'end', 'sum') regardless of the input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-26T21:02:46.000Z"
    },
    {
      "id": "gfg-medium-undirected-graph-cycle",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Undirected Graph Cycle",
      "language": "java",
      "files": {
        "code": "import java.util.*;\r\n\r\nclass Solution {\r\n    public boolean isCycle(int V, int[][] edges) {\r\n        // Build adjacency list\r\n        List<List<Integer>> adj = new ArrayList<>();\r\n        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());\r\n\r\n        for (int[] edge : edges) {\r\n            int u = edge[0], v = edge[1];\r\n            adj.get(u).add(v);\r\n            adj.get(v).add(u); // undirected graph\r\n        }\r\n\r\n        boolean[] visited = new boolean[V];\r\n\r\n        // Check all components\r\n        for (int i = 0; i < V; i++) {\r\n            if (!visited[i]) {\r\n                if (dfs(i, -1, visited, adj)) {\r\n                    return true; // cycle found\r\n                }\r\n            }\r\n        }\r\n\r\n        return false; // no cycle\r\n    }\r\n\r\n    // DFS helper function\r\n    private boolean dfs(int node, int parent, boolean[] visited, List<List<Integer>> adj) {\r\n        visited[node] = true;\r\n\r\n        for (int neigh : adj.get(node)) {\r\n            if (!visited[neigh]) {\r\n                if (dfs(neigh, node, visited, adj)) return true;\r\n            } \r\n            // if neighbor is visited and not parent -> cycle\r\n            else if (neigh != parent) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}",
        "readme": "Undirected Graph Cycle\nDifficulty: MediumAccuracy: 30.13%Submissions: 630K+Points: 4Average Time: 20m\n\nGiven an undirected graph with V vertices and E edges, represented as a 2D vector edges[][], where each entry edges[i] = [u, v] denotes an edge between vertices u and v, determine whether the graph contains a cycle or not. The graph can have multiple component.\n\nExamples:\n\nInput: V = 4, E = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 3]]\nOutput: true\nExplanation: \n \n1 -> 2 -> 0 -> 1 is a cycle.\n\nInput: V = 4, E = 3, edges[][] = [[0, 1], [1, 2], [2, 3]]\nOutput: false\nExplanation: \n \nNo cycle in the graph.\n\n\nConstraints:\n1¬†‚â§ V¬†‚â§¬†105\n1 ‚â§ E = edges.size() ‚â§ 105\n\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": "# Undirected Graph Cycle\n\n          **Summary:** This code implements a solution using Java (21). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T18:48:58.000Z"
    },
    {
      "id": "gfg-hard-edit-distance",
      "platform": "Gfg",
      "difficulty": "Hard",
      "problemName": "Edit Distance",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    int editDistance(string& s1, string& s2) {\r\n        int n = s1.size(), m = s2.size();\r\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\r\n        \r\n        // Base cases\r\n        for (int i = 0; i <= n; i++) dp[i][0] = i;  // remove all\r\n        for (int j = 0; j <= m; j++) dp[0][j] = j;  // insert all\r\n        \r\n        // DP relation\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (s1[i - 1] == s2[j - 1]) {\r\n                    dp[i][j] = dp[i - 1][j - 1];  // no operation\r\n                } else {\r\n                    dp[i][j] = 1 + min({\r\n                        dp[i - 1][j],     // remove\r\n                        dp[i][j - 1],     // insert\r\n                        dp[i - 1][j - 1]  // replace\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return dp[n][m];\r\n    }\r\n};",
        "readme": "Edit Distance\nDifficulty: HardAccuracy: 35.14%Submissions: 243K+Points: 8\n\nGiven two strings s1 and s2. Return the minimum number of operations required to convert s1 to s2.\nThe possible operations are permitted:\n\nInsert a character at any position of the string.\nRemove any character from the string.\nReplace any character from the string with any other character.\n\nExamples:\n\n\nInput: s1 = \"geek\", s2 = \"gesek\"\nOutput:¬†1\nExplanation: One operation is required, inserting 's' between two 'e' in s1.\nInput: s1 = \"gfg\", s2 = \"gfg\"\nOutput: 0\nExplanation: Both strings are same.\n\nInput: s1 = \"abcd\", s2 = \"bcfe\"\nOutput: 3\nExplanation: We can convert s1 into s2 by removing ‚Äòa‚Äô, replacing ‚Äòd‚Äô with ‚Äòf‚Äô and inserting ‚Äòe‚Äô at the end. \n\nConstraints:\n1 ‚â§ s1.length(), s2.length() ‚â§ 103\nBoth the strings are in lowercase.\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Articles",
        "notes": "# Edit Distance\n\n          **Summary:** This code implements a solution using C++ (12). It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T18:50:15.000Z"
    },
    {
      "id": "hackerrank-medium-array-manipulation",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Array Manipulation",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'arrayManipulation' function below.\n *\n * The function is expected to return a LONG_INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER n\n *  2. 2D_INTEGER_ARRAY queries\n */\n\nlong arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long long> arr(n + 2, 0);\n\n    for (auto &q : queries) {\n        int a = q[0], b = q[1], k = q[2];\n        arr[a] += k;\n        arr[b + 1] -= k;\n    }\n\n    long long maxVal = 0, curr = 0;\n    for (int i = 1; i <= n; i++) {\n        curr += arr[i];\n        maxVal = max(maxVal, curr);\n    }\n\n    return maxVal;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int m = stoi(first_multiple_input[1]);\n\n    vector<vector<int>> queries(m);\n\n    for (int i = 0; i < m; i++) {\n        queries[i].resize(3);\n\n        string queries_row_temp_temp;\n        getline(cin, queries_row_temp_temp);\n\n        vector<string> queries_row_temp = split(rtrim(queries_row_temp_temp));\n\n        for (int j = 0; j < 3; j++) {\n            int queries_row_item = stoi(queries_row_temp[j]);\n\n            queries[i][j] = queries_row_item;\n        }\n    }\n\n    long result = arrayManipulation(n, queries);\n\n    fout << result << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\n\nExample\n\n\n\nQueries are interpreted as follows:\n\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\n\n\nAdd the values of  between the indices  and  inclusive:\n\nThe largest value is  after all operations are performed.\n\nFunction Description\n\nComplete the function  with the following parameters:\n\n: the number of elements in the array\n: a two dimensional array of queries where each  contains three integers, , , and .\n\nReturns\n\n: the maximum value in the resultant array\n\nInput Format\n\nThe first line contains two space-separated integers  and , the size of the array and the number of queries.\nEach of the next  lines contains three space-separated integers ,  and , the left index, right index and number to add.\n\nConstraints\n\nSample Input\n\nSTDIN       Function\n-----       --------\n5 3         arr[] size n = 5, queries[] size q = 3\n1 2 100     queries = [[1, 2, 100], [2, 5, 100], [3, 4, 100]]\n2 5 100\n3 4 100\n\n\nSample Output\n\n200\n\n\nExplanation\n\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\n\nThe maximum value is .",
        "notes": "# Array Manipulation\n\n          **Summary:** This code implements a solution using C++11. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-25T19:01:55.000Z"
    },
    {
      "id": "hackerrank-medium-arrays---ds",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Arrays - DS",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'reverseArray' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts INTEGER_ARRAY a as parameter.\n */\n\nvector<int> reverseArray(vector<int> a) {\n    reverse(a.begin(), a.end());  // use STL reverse\n    return a;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(arr_count);\n\n    for (int i = 0; i < arr_count; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> res = reverseArray(arr);\n\n    for (size_t i = 0; i < res.size(); i++) {\n        fout << res[i];\n\n        if (i != res.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "null\n\nAn array is a data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  or .\n\nYour task is to reverse an array of integers.\n\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\n\nExample\n\n\nReturn .\n\nFunction Description\n\nComplete the function  with the following parameter(s):\n\n: the array to reverse\n\nReturns\n\n: the reversed array\n\nInput Format\n\nThe first line contains an integer, , the number of integers in .\nThe second line contains  space-separated integers that make up .\n\nConstraints",
        "notes": "Array Reversal\n\n          - Summary: The code uses vectors (dynamic arrays) to store and manipulate integer data.  It first reads an array of integers from standard input, then reverses the array using the STL `reverse` function. Finally, it writes the reversed array to standard output.  Helper functions handle input string trimming and splitting.\n\n          - Time Complexity: O(n), where n is the number of elements in the input array. This is because the `reverse` function, and the input/output loops all iterate linearly through the array once.\n          - Space Complexity: O(n), where n is the number of elements in the input array. This is due to the space used by the input array and the reversed array. The helper functions have minimal space overhead."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-01T21:17:35.000Z"
    },
    {
      "id": "hackerrank-medium-binary-search-tree---insertion",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Binary Search Tree : Insertion",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n\nclass Solution {\n    public:\n  \t\n  \tvoid preOrder(Node *root) {\n\t\t\n      \tif( root == NULL )\n          \treturn;\n      \n      \tstd::cout << root->data << \" \";\n      \t\n      \tpreOrder(root->left);\n      \tpreOrder(root->right);\n    }\n\n/*\nNode is defined as \n\nclass Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n\n*/\n\n    Node * insert(Node * root, int data) {\n    if (root == NULL) {\n        return new Node(data);\n    }\n\n    if (data <= root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n\n    return root;\n}\n\n\n};\n\nint main() {\n  \n    Solution myTree;\n    Node* root = NULL;\n    \n    int t;\n    int data;\n\n    std::cin >> t;\n\n    while(t-- > 0) {\n        std::cin >> data;\n        root = myTree.insert(root, data);\n    }\n  \t\n    myTree.preOrder(root);\n  \n    return 0;\n}",
        "readme": "",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": false,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T11:32:05.000Z"
    },
    {
      "id": "hackerrank-medium-dynamic-array",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Dynamic Array",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'dynamicArray' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts following parameters:\n *  1. INTEGER n\n *  2. 2D_INTEGER_ARRAY queries\n */\n\nvector<int> dynamicArray(int n, vector<vector<int>> queries) {\n    vector<vector<int>> seqList(n); // n empty sequences\n    int lastAnswer = 0;\n    vector<int> answers; // stores results of type 2 queries\n\n    for (auto &q : queries) {\n        int type = q[0];\n        int x = q[1];\n        int y = q[2];\n\n        int idx = (x ^ lastAnswer) % n;\n\n        if (type == 1) {\n            // Append y to seqList[idx]\n            seqList[idx].push_back(y);\n        } else if (type == 2) {\n            // Find the element\n            int value = seqList[idx][y % seqList[idx].size()];\n            lastAnswer = value;\n            answers.push_back(lastAnswer);\n        }\n    }\n    return answers;\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int q = stoi(first_multiple_input[1]);\n\n    vector<vector<int>> queries(q);\n\n    for (int i = 0; i < q; i++) {\n        queries[i].resize(3);\n\n        string queries_row_temp_temp;\n        getline(cin, queries_row_temp_temp);\n\n        vector<string> queries_row_temp = split(rtrim(queries_row_temp_temp));\n\n        for (int j = 0; j < 3; j++) {\n            int queries_row_item = stoi(queries_row_temp[j]);\n\n            queries[i][j] = queries_row_item;\n        }\n    }\n\n    vector<int> result = dynamicArray(n, queries);\n\n    for (size_t i = 0; i < result.size(); i++) {\n        fout << result[i];\n\n        if (i != result.size() - 1) {\n            fout << \"\\n\";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "null\n\nDeclare a 2-dimensional array, , with  empty arrays, all zero-indexed.\nDeclare an integer, , and initialize it to 0.\n\nYou need to process two types of queries:\n\nQuery: \n\nCompute .\nAppend the integer  to .\n\nQuery: \n\nCompute .\nSet .\nStore the new value of  in an answers array.\n\nNotes:\n-  is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia.\n-  is the modulo operator.\n- Finally,  is the number of elements in .\n\nFunction Description\n\nComplete the  function with the following parameters:\n- : the number of empty arrays to initialize in \n- : 2-D array of integers\n\nReturns\n\n: the results of each type 2 query in the order they are presented\n\nInput Format\n\nThe first line contains two space-separated integers, , the size of  to create, and , the number of queries, respectively.\nEach of the  subsequent lines contains a query string, .\n\nConstraints\n\nIt is guaranteed that query type  will never query an empty array or index.\n\nSample Input\n\nSTDIN    Function\n-----    --------\n2 5      size of arr[] n = 2, size of queries[] q = 5\n1 0 5    queries = [[1,0,5],[1,1,7],[1,0,3],[2,1,0],[2,1,1]]\n1 1 7\n1 0 3\n2 1 0\n2 1 1\n\n\nSample Output\n\n7\n3\n\n\nExplanation\n\nInitial Values:\n\n\n = [ ]\n = [ ]\n\nQuery 0: Append  to .\n\n = [5]\n = [ ]\n\nQuery 1: Append  to .\n = [5]\n = [7]\n\nQuery 2: Append  to .\n\n = [5, 3]\n = [7]\n\nQuery 3: Assign the value at index  of  to . Store  in your answer array. \n = [5, 3]\n = [7]\n\nQuery 4: Assign the value at index  of  to . Store  in your answer array. \n = [5, 3]\n = [7]\n\nReturn your answer array [7, 3]. The code stub prints its elements on separate lines.",
        "notes": "Dynamic Array\n\n          - Summary: The code implements a dynamic array using a vector of vectors.  It processes queries of two types: type 1 appends an element to a specific sequence within the dynamic array, and type 2 retrieves an element from a sequence and updates a lastAnswer variable. The algorithm iterates through the queries, performing the appropriate operation based on the query type, using bitwise XOR to calculate indices and modulo operations to handle array bounds. The results of type 2 queries are stored and returned.\n\n          - Time Complexity: O(q), where q is the number of queries.  The dominant operation is iterating through the queries.  Appending elements to vectors is amortized O(1).\n          - Space Complexity: O(n + q), where n is the size of the dynamic array and q is the number of queries. The space is used primarily for the dynamic array (seqList) and the answers vector. The size of seqList depends on n, and the size of answers depends on the number of type 2 queries."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T21:18:45.000Z"
    },
    {
      "id": "hackerrank-medium-find-merge-point-of-two-lists",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Find Merge Point of Two Lists",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n// Complete the findMergeNode function below.\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\nint findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {\n    // Step 1: compute lengths of both lists\n    int len1 = 0, len2 = 0;\n    SinglyLinkedListNode* curr1 = head1;\n    SinglyLinkedListNode* curr2 = head2;\n\n    while (curr1) {\n        len1++;\n        curr1 = curr1->next;\n    }\n    while (curr2) {\n        len2++;\n        curr2 = curr2->next;\n    }\n\n    // Step 2: advance the longer list by the difference in lengths\n    curr1 = head1;\n    curr2 = head2;\n    if (len1 > len2) {\n        int diff = len1 - len2;\n        while (diff--) curr1 = curr1->next;\n    } else {\n        int diff = len2 - len1;\n        while (diff--) curr2 = curr2->next;\n    }\n\n    // Step 3: move both pointers until they meet\n    while (curr1 && curr2) {\n        if (curr1 == curr2) {\n            return curr1->data; // found merge point\n        }\n        curr1 = curr1->next;\n        curr2 = curr2->next;\n    }\n\n    return -1; // should not happen given the problem guarantee\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int tests;\n    cin >> tests;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {\n        int index;\n        cin >> index;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        SinglyLinkedList* llist1 = new SinglyLinkedList();\n\n        int llist1_count;\n        cin >> llist1_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist1_count; i++) {\n            int llist1_item;\n            cin >> llist1_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist1->insert_node(llist1_item);\n        }\n      \n      \tSinglyLinkedList* llist2 = new SinglyLinkedList();\n\n        int llist2_count;\n        cin >> llist2_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist2_count; i++) {\n            int llist2_item;\n            cin >> llist2_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist2->insert_node(llist2_item);\n        }\n      \n      \tSinglyLinkedListNode* ptr1 = llist1->head;\n      \tSinglyLinkedListNode* ptr2 = llist2->head;\n      \n      \tfor (int i = 0; i < llist1_count; i++) {\n            if (i < index) {\n          \t\tptr1 = ptr1->next;\n            }\n        }\n      \n      \tfor (int i = 0; i < llist2_count; i++) {\n          \tif (i != llist2_count-1) {\n          \t\tptr2 = ptr2->next;\n            }\n        }\n      \n      \tptr2->next = ptr1;\n\n        int result = findMergeNode(llist1->head, llist2->head);\n\n        fout << result << \"\\n\";\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "This challenge is part of a tutorial track by MyCodeSchool\n\nGiven pointers to the head nodes of  linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's  value.\n\nNote: After the merge point, both lists will share the same node pointers.\n\nExample\n\nIn the diagram below, the two lists converge at Node x:\n\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     /\n     [List #2] p--->q\n\n\nFunction Description\n\nComplete the findMergeNode function in the editor below.\n\nfindMergeNode has the following parameters:\n\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\n\nReturns\n\nint: the  value of the node where the lists merge\n\nInput Format\n\nDo not read any input from stdin/console.\n\nThe first line contains an integer , the number of test cases.\n\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer,  that is the number of nodes in the first list.\nEach of the following  lines contains a  value for a node. The next line contains an integer,  that is the number of nodes in the second list.\nEach of the following  lines contains a  value for a node.\n\nConstraints\n\nThe lists will merge.\n.\n .\n\nSample Input\n\nThe diagrams below are graphical representations of the lists that input nodes  and  are connected to.\n\nTest Case 0\n\n 1\n  \\\n   2--->3--->NULL\n  /\n 1\n\n\nTest Case 1\n\n1--->2\n      \\\n       3--->Null\n      /\n     1\n\n\nSample Output\n\n2\n3\n\n\nExplanation\n\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "notes": "Find Merge Point of Two Lists\n\n          - Summary: The code utilizes singly linked lists to represent two lists. The `findMergeNode` function first calculates the lengths of both lists.  Then, it advances the pointer of the longer list to align both pointers at the same distance from the merge point. Finally, it iterates through both lists simultaneously until it finds the node where both pointers are equal, returning the data of that node as the merge point.\n\n          - Time Complexity: O(m+n), where 'm' and 'n' are the lengths of the two linked lists. This is because the algorithm iterates through each list once to determine its length and then iterates through portions of each list to find the merge point.\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space to store variables like lengths and pointers; it doesn't scale with the size of the input lists."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T20:50:31.000Z"
    },
    {
      "id": "hackerrank-medium-inserting-a-node-into-a-sorted-doubly-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Inserting a Node Into a Sorted Doubly Linked List",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass DoublyLinkedListNode {\n    public:\n        int data;\n        DoublyLinkedListNode *next;\n        DoublyLinkedListNode *prev;\n\n        DoublyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n            this->prev = nullptr;\n        }\n};\n\nclass DoublyLinkedList {\n    public:\n        DoublyLinkedListNode *head;\n        DoublyLinkedListNode *tail;\n\n        DoublyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            DoublyLinkedListNode* node = new DoublyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n                node->prev = this->tail;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_doubly_linked_list(DoublyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_doubly_linked_list(DoublyLinkedListNode* node) {\n    while (node) {\n        DoublyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n/*\n * Complete the 'sortedInsert' function below.\n *\n * The function is expected to return an INTEGER_DOUBLY_LINKED_LIST.\n * The function accepts following parameters:\n *  1. INTEGER_DOUBLY_LINKED_LIST llist\n *  2. INTEGER data\n */\n\n/*\n * For your reference:\n *\n * DoublyLinkedListNode {\n *     int data;\n *     DoublyLinkedListNode* next;\n *     DoublyLinkedListNode* prev;\n * };\n *\n */\n\nDoublyLinkedListNode* sortedInsert(DoublyLinkedListNode* llist, int data) {\n    DoublyLinkedListNode* newNode = new DoublyLinkedListNode(data);\n\n    // Case 1: empty list\n    if (!llist) {\n        return newNode;\n    }\n\n    // Case 2: insert before head\n    if (data <= llist->data) {\n        newNode->next = llist;\n        llist->prev = newNode;\n        return newNode; // new head\n    }\n\n    // Case 3: traverse to find insertion point\n    DoublyLinkedListNode* curr = llist;\n    while (curr->next && curr->next->data < data) {\n        curr = curr->next;\n    }\n\n    // Insert after curr\n    newNode->next = curr->next;\n    newNode->prev = curr;\n    if (curr->next) {\n        curr->next->prev = newNode;\n    }\n    curr->next = newNode;\n\n    return llist; // head remains unchanged\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int t;\n    cin >> t;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int t_itr = 0; t_itr < t; t_itr++) {\n        DoublyLinkedList* llist = new DoublyLinkedList();\n\n        int llist_count;\n        cin >> llist_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist_count; i++) {\n            int llist_item;\n            cin >> llist_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist->insert_node(llist_item);\n        }\n\n        int data;\n        cin >> data;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        DoublyLinkedListNode* llist1 = sortedInsert(llist->head, data);\n\n        print_doubly_linked_list(llist1, \" \", fout);\n        fout << \"\\n\";\n\n        free_doubly_linked_list(llist1);\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value  and insert it at the proper location to maintain the sort.\n\nExample\n\n refers to the list \n\n\nReturn a reference to the new list: .\n\nFunction Description\n\nComplete the sortedInsert function in the editor below.\n\nsortedInsert has two parameters:\n\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\n\nint data: An integer denoting the value of the  field for the DoublyLinkedListNode you must insert into the list.\n\nReturns\n\nDoublyLinkedListNode pointer: a reference to the head of the list\n\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\n\nInput Format\n\nThe first line contains an integer , the number of test cases.\n\nEach of the test case is in the following format:\n\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next  lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\n\nConstraints\n\nSample Input\n\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\n\n\nSample Output\n\n1 3 4 5 10\n\n\nExplanation\n\nThe initial doubly linked list is:  .\n\nThe doubly linked list after insertion is:",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T11:35:20.000Z"
    },
    {
      "id": "hackerrank-medium-left-rotation",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Left Rotation",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'rotateLeft' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts following parameters:\n *  1. INTEGER d\n *  2. INTEGER_ARRAY arr\n */\n\nvector<int> rotateLeft(int d, vector<int> arr) {\n    int n = arr.size();\n    d = d % n; // handle cases when d >= n\n    vector<int> rotated(n);\n\n    for (int i = 0; i < n; i++) {\n        rotated[i] = arr[(i + d) % n];\n    }\n\n    return rotated;\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int d = stoi(first_multiple_input[1]);\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(n);\n\n    for (int i = 0; i < n; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> result = rotateLeft(d, arr);\n\n    for (size_t i = 0; i < result.size(); i++) {\n        fout << result[i];\n\n        if (i != result.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "A  operation on a circular array shifts each of the array's elements  unit to the left. The elements that fall off the left end reappear at the right end. Given an integer , rotate the array that many steps to the left and return the result.\n\nExample\n\n\n\nAfter  rotations, .\n\nFunction Description\n\nComplete the  function with the following parameters:\n\n: the amount to rotate by\n: the array to rotate\n\nReturns\n\n: the rotated array\n\nInput Format\n\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains  space-separated integers that describe .\n\nConstraints\n\nSample Input\n\nSTDIN      Function\n-----      --------\n5 4         n = 5 d = 4\n1 2 3 4 5  arr = [1, 2, 3, 4, 5]\n\n\nSample Output\n\n5 1 2 3 4\n\n\nExplanation\n\nTo perform  left rotations, the array undergoes the following sequence of changes:",
        "notes": "# Left Rotation\n\n          **Summary:** This code implements a solution using C++11. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nÔøΩ)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T13:29:07.000Z"
    },
    {
      "id": "hackerrank-medium-median-updates",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Median Updates",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<int> leftHalf, rightHalf;\n\nvoid rebalance() {\n    // keep sizes balanced (|left| = |right| or |left| = |right| + 1)\n    while (leftHalf.size() > rightHalf.size() + 1) {\n        rightHalf.insert(*leftHalf.rbegin());\n        leftHalf.erase(prev(leftHalf.end()));\n    }\n    while (rightHalf.size() > leftHalf.size()) {\n        leftHalf.insert(*rightHalf.begin());\n        rightHalf.erase(rightHalf.begin());\n    }\n}\n\nvoid addNumber(int x) {\n    if (leftHalf.empty() || x <= *leftHalf.rbegin()) {\n        leftHalf.insert(x);\n    } else {\n        rightHalf.insert(x);\n    }\n    rebalance();\n}\n\nbool removeNumber(int x) {\n    if (leftHalf.find(x) != leftHalf.end()) {\n        leftHalf.erase(leftHalf.find(x));\n    } else if (rightHalf.find(x) != rightHalf.end()) {\n        rightHalf.erase(rightHalf.find(x));\n    } else {\n        return false; // number not found\n    }\n    rebalance();\n    return true;\n}\n\nvoid printMedian() {\n    if (leftHalf.empty() && rightHalf.empty()) {\n        cout << \"Wrong!\" << endl;\n        return;\n    }\n    if (leftHalf.size() > rightHalf.size()) {\n        cout << *leftHalf.rbegin() << endl;\n    } else {\n        long long a = *leftHalf.rbegin();\n        long long b = *rightHalf.begin();\n        long long sum = a + b;\n        if (sum % 2 == 0) cout << sum / 2 << endl;\n        else cout << fixed << setprecision(1) << sum / 2.0 << endl;\n    }\n}\n\nvoid median(vector<char> s, vector<int> X) {\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (s[i] == 'a') {\n            addNumber(X[i]);\n            printMedian();\n        } else {\n            if (!removeNumber(X[i])) {\n                cout << \"Wrong!\" << endl;\n            } else {\n                printMedian();\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<char> s;\n    vector<int> X;\n    char temp;\n    int tempint;\n\n    for (int i = 0; i < N; i++) {\n        cin >> temp >> tempint;\n        s.push_back(temp);\n        X.push_back(tempint);\n    }\n\n    median(s, X);\n    return 0;\n}",
        "readme": "null\n\nThe median of  numbers is defined as the middle number after sorting them in order if  is odd. Or it is the average of the middle two numbers if  is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median.\n\nExample:\nFor a set of  numbers  the median is the third number in the sorted set , which is . Similarly, for a set of  numbers, , the median is the average of the second and the third element in the sorted set , which is . ¬†\n\nInput:\nThe first line is an integer, , that indicates the number of operations. Each of the next  lines is either a x or r x. a x indicates that  is added to the set, and r x indicates that  is removed from the set.\n\nOutput:\nFor each operation: If the operation is add, output the median after adding  in a single line. If the operation is remove and the number  is not in the list, output Wrong! in a single line. If the operation is remove and the number  is in the list, output the median after deleting  in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.)\n\nNote\nIf your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong!\n\nConstraints:\n\nFor each a x or r x,  will always be a signed integer (which will fit in 32 bits).\n\nSample Input:\n\n7  \nr 1  \na 1  \na 2  \na 1  \nr 1  \nr 2  \nr 1  \n\n\nSample Output:\n\nWrong!  \n1  \n1.5  \n1  \n1.5  \n1  \nWrong!\n\n\nNote: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!.",
        "notes": "Median Updates\n\n          - Summary: This C++ code maintains a dynamic median of a stream of numbers using two multisets, `leftHalf` and `rightHalf`, to store the smaller and larger halves of the data, respectively.  The `addNumber` function inserts a new number into the appropriate half, and `rebalance` ensures the sizes of the multisets differ by at most one. The `removeNumber` function removes a number and rebalances.  The `printMedian` function computes and prints the median based on the sizes of the multisets.\n\n          - Time Complexity: O(n log n).  The `addNumber` and `removeNumber` functions, which are called n times, involve operations on multisets which have logarithmic time complexity for insertion, deletion, and finding the smallest/largest element. The rebalancing operation is also logarithmic in the number of elements.\n          - Space Complexity: O(n). The multisets `leftHalf` and `rightHalf` store at most n numbers in total, and the input vectors `s` and `X` also take O(n) space."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-10T05:23:10.000Z"
    },
    {
      "id": "hackerrank-medium-print-the-elements-of-a-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Print the Elements of a Linked List",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n            }\n\n            this->tail = node;\n        }\n};\n\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n// Complete the printLinkedList function below.\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\nvoid printLinkedList(SinglyLinkedListNode* head) {\n    SinglyLinkedListNode* current = head;\n    while (current != nullptr) {\n        cout << current->data << \"\\n\"; // print each node's data\n        current = current->next;       // move to next node\n    }\n}\n\n\nint main()\n{\n    SinglyLinkedList* llist = new SinglyLinkedList();\n\n    int llist_count;\n    cin >> llist_count;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int i = 0; i < llist_count; i++) {\n        int llist_item;\n        cin >> llist_item;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        llist->insert_node(llist_item);\n    }\n\n    printLinkedList(llist->head);\n\n    return 0;\n}",
        "readme": "null\n\nThis challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\n\nThis exercise focuses on traversing a linked list. You are given a pointer to the  node of a linked list. The task is to print the  of each node, one per line. If the head pointer is , indicating the list is empty, nothing should be printed.\n\nFunction Description\n\nComplete the  function with the following parameter(s):\n\n: a reference to the head of the list\n\nPrint\n\nFor each node, print its  value on a new line (console.log in Javascript).\n\nInput Format\n\nThe first line of input contains , the number of elements in the linked list.\nThe next  lines contain one element each, the  values for each node.\n\nNote: Do not read any input from stdin/console. Complete the printLinkedList function in the editor below.\n\nConstraints\n\n, where  is the  element of the linked list.\n\nSample Input\n\nSTDIN   Function\n-----   --------\n2       n = 2\n16      first data value = 16\n13      second data value = 13\n\n\nSample Output\n\n16\n13\n\n\nExplanation\n\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the  function should print 16 and 13 each on a new line.",
        "notes": "Print the Elements of a Linked List\n\n          - Summary: The code utilizes a singly linked list data structure to store integer values.  The `main` function first takes input from the user to determine the number of nodes and their respective data. These nodes are then inserted into the linked list using the `insert_node` function. Finally, the `printLinkedList` function iterates through the list and prints the data of each node to the console.\n\n          - Time Complexity: O(n), where n is the number of nodes in the linked list. This is because `printLinkedList` iterates through each node once to print its data.\n          - Space Complexity: O(n), where n is the number of nodes in the linked list. The space used is proportional to the number of nodes stored in the linked list."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T19:26:44.000Z"
    },
    {
      "id": "hackerrank-medium-reverse-a-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Reverse a linked list",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n        void insert_node(int node_data) {\n            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);\n\n            if (!this->head) {\n                this->head = node;\n            } else {\n                this->tail->next = node;\n            }\n\n            this->tail = node;\n        }\n};\n\nvoid print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n/*\n * Complete the 'reverse' function below.\n *\n * The function is expected to return an INTEGER_SINGLY_LINKED_LIST.\n * The function accepts INTEGER_SINGLY_LINKED_LIST llist as parameter.\n */\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\n\nSinglyLinkedListNode* reverse(SinglyLinkedListNode* llist) {\n    SinglyLinkedListNode* prev = nullptr;\n    SinglyLinkedListNode* curr = llist;\n\n    while (curr != nullptr) {\n        SinglyLinkedListNode* nextNode = curr->next; // save next\n        curr->next = prev;                           // reverse pointer\n        prev = curr;                                 // move prev\n        curr = nextNode;                             // move curr\n    }\n\n    return prev; // new head\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int tests;\n    cin >> tests;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {\n        SinglyLinkedList* llist = new SinglyLinkedList();\n\n        int llist_count;\n        cin >> llist_count;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        for (int i = 0; i < llist_count; i++) {\n            int llist_item;\n            cin >> llist_item;\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n            llist->insert_node(llist_item);\n        }\n\n        SinglyLinkedListNode* llist1 = reverse(llist->head);\n\n        print_singly_linked_list(llist1, \" \", fout);\n        fout << \"\\n\";\n\n        free_singly_linked_list(llist1);\n    }\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\n\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\n\nExample\n references the list \n\nManipulate the  pointers of each node in place and return , now referencing the head of the list .\n\nFunction Description\n\nComplete the reverse function in the editor below.\n\nreverse has the following parameter:\n\nSinglyLinkedListNode pointer head: a reference to the head of a list\n\nReturns\n\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\n\nInput Format\n\nThe first line contains an integer , the number of test cases.\n\nEach test case has the following format:\n\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next  lines contains an integer, the  values of the elements in the linked list.\n\nConstraints\n\n, where  is the  element in the list.\n\nSample Input\n\n1\n5\n1\n2\n3\n4\n5\n\n\nSample Output\n\n5 4 3 2 1 \n\n\nExplanation\n\nThe initial linked list is: .\n\nThe reversed linked list is: .",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T11:54:23.000Z"
    },
    {
      "id": "leetcode-easy-remove-duplicates-from-sorted-list",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Remove Duplicates from Sorted List",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) return nullptr;\n        \n        ListNode* curr = head;\n        while (curr && curr->next) {\n            if (curr->val == curr->next->val) {\n                // Skip the duplicate node\n                ListNode* temp = curr->next;\n                curr->next = curr->next->next;\n                delete temp;  // free memory if needed\n            } else {\n                curr = curr->next;\n            }\n        }\n        return head;\n    }\n};",
        "readme": "83. Remove Duplicates from Sorted ListSolvedEasyTopicsCompaniesGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\n¬†\nExample 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n\n¬†\nConstraints:\n\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,054,992/3.7MAcceptance Rate55.3%TopicsLinked ListCompaniesSimilar QuestionsRemove Duplicates from Sorted List IIMediumRemove Duplicates From an Unsorted Linked ListMediumDiscussion (135)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestM1dn1ghtNov 12, 2023if this was easy i dont even want to see a medium linked list problem¬†Read more15715LeetCanCodeSep 07, 2023Additional tests:\n[1,1,1]\n[1,2,2]\n[1,1,2,3,3]\n[1,1,2,2,3,3]\n[1,2,2,3]\n[1]\n[]\n[1,1]¬†Read moreTip574anlunxJun 13, 2019Why give a null test case?¬†Read more273SamikshaApr 22, 2022Hi.\nI'm new to python programming. It'd be very helpful if someone can explain why do we use Optional?\n'''\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n'''\n**Here, why do we use Optional[ListNode]? How is it useful? **¬†Read more257AaryanSep 10, 2023Simple Approach\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\n\n\nInitialize a pointer to head, here I used 'temp' and iterate it over the linked list.\n\n\nIn each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of 'temp' to temp->next->next;\n\n\nWhile we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\n\n\nBut if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values.\n\n¬†Read moreTip225rostikcode15Mar 29, 2025FIRST TIME, solved some easy leetcode problem in less then 20 minutes, i am so proud of myself, lezzgo¬†Read more121rashmi_jain18Nov 03, 2022Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\nvar current = head;\nwhile (current.next != null) {\nif (current.next.val == current.val) {\ncurrent.next = current.next.next;\n}\nelse {\ncurrent = current.next;\n}\n}\nIs it because its reference type?¬†Read moreAsk Question106NicaishishaDec 29, 2013In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here.¬†Read more84Shivam SharmaSep 27, 2024Move to the next node only when data in the next node is not equal.\nThis will be helpful test cases like [1, 1, 1].¬†Read moreTip71yuuJan 08, 2025Linked lists aint real¬†Read more3123414Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T15:15:53.000Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "python",
      "files": {
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pair_idx = {}\n\n        for i, num in enumerate(nums):\n            if target - num in pair_idx:\n                return [i, pair_idx[target - num]]\n            pair_idx[num] = i",
        "readme": "ArrayHashTable\n\nGiven an array of integers nums¬†and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n¬†\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n¬†\nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n¬†\nFollow-up:¬†Can you come up with an algorithm that is less than O(n2)¬†time complexity?",
        "notes": "Two Sum\n\n          - Summary: The code utilizes a HashMap to store each number in the input array 'nums' as a key and its index as the value. It then iterates through the array; for each number, it calculates the complement needed to reach the target.  The algorithm checks if this complement exists as a key in the HashMap. If found and its index differs from the current index, it means a pair adding up to the target is found, and their indices are returned. Otherwise, the loop continues until a pair is found or the array is exhausted.\n\n          - Time Complexity: O(n) because the code iterates through the input array 'nums' once to populate the HashMap and then iterates through it again, resulting in a linear time complexity with respect to the size of the input array.\n          - Space Complexity: O(n) because the HashMap 'mp' stores at most n key-value pairs, where n is the length of the input array 'nums'. The space used grows linearly with the input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-10T05:26:49.000Z"
    },
    {
      "id": "leetcode-easy-valid-anagram",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Valid Anagram",
      "language": "java",
      "files": {
        "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        // HashMap <Character,Integer> mapS = new HashMap<>();\n        // HashMap <Character,Integer> mapT = new HashMap<>();\n\n        // for(int i=0;i<s.length();i++){\n        //     char charS = s.charAt(i);     \n        //     char charT = t.charAt(i);\n            \n        //     // \n        //     mapS.put(charS, mapS.getOrDefault(charS, 0) + 1);\n        //     mapT.put(charT, mapT.getOrDefault(charT, 0) + 1);\n        // }\n        // return mapS.equals(mapT);\n        char[] originalArr = s.toCharArray();\n        char[] modifiedArr = t.toCharArray();\n\n        Arrays.sort(originalArr);\n        Arrays.sort(modifiedArr);\n\n        return Arrays.equals(originalArr, modifiedArr);\n    }\n}",
        "readme": "HashTableStringSorting\n\nGiven two strings s and t, return true if t is an anagram of s, and false otherwise.\n\n¬†\nExample 1:\n\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false\n\n\n¬†\nConstraints:\n\n\n\t1 <= s.length, t.length <= 5 * 104\n\ts and t consist of lowercase English letters.\n\n\n¬†\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-09-27T08:31:02.000Z"
    },
    {
      "id": "leetcode-medium-combination-sum-ii",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Combination Sum II",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> curr;\n\n    void backtrack(vector<int>& candidates, int target, int start) {\n        if (target == 0) {\n            res.push_back(curr);\n            return;\n        }\n\n        for (int i = start; i < candidates.size(); i++) {\n            // Skip duplicates\n            if (i > start && candidates[i] == candidates[i - 1]) continue;\n\n            if (candidates[i] > target) break; // pruning\n\n            curr.push_back(candidates[i]);\n            backtrack(candidates, target - candidates[i], i + 1);\n            curr.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtrack(candidates, target, 0);\n        return res;\n    }\n};",
        "readme": "40. Combination Sum IISolvedMediumTopicsCompaniesGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates¬†where the candidate numbers sum to target.\n\nEach number in candidates¬†may only be used once in the combination.\n\nNote:¬†The solution set must not contain duplicate combinations.\n\n¬†\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n¬†\nConstraints:\n\n\n\t1 <=¬†candidates.length <= 100\n\t1 <=¬†candidates[i] <= 50\n\t1 <= target <= 30\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted1,477,286/2.5MAcceptance Rate58.1%TopicsArrayBacktrackingCompaniesSimilar QuestionsCombination SumMediumDiscussion (191)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:Bestananta_srivastavaJan 17, 2023where in the question is it mentioned that th ans should be in sorted order?¬†Read more28710Nachiketa BhoraniyaMar 07, 2023to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\ntarget = 29¬†Read more86PurdueKumarNov 02, 2018This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution.¬†Read more881Aditya KumarAug 13, 2024TESTCASES------------>\n[10,1,2,7,6,1,5]\n8\n[2,5,2,1,2]\n5\n[2, 2, 2, 2, 3, 6, 7]\n9\n[1, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10]\n 25\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\n29\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n30\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\n30\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n 15¬†Read more391James_NagarJul 09, 2024When you consider just consider and move forward, but when you do not consider than do not consider any of it's duplicate, how you make sure it -> just Sort the array and skip all adjacent duplicate elements when you do not consider.¬†Read moreTip5511RafiaDec 01, 2024#TLE 172/176üíî¬†Read more611aman_mnnitOct 01, 2022how to make sure my vector<vector> ans does not contain duplicate values without using set?¬†Read moreAsk Question3119NoahSep 09, 2023Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\nA bit of code for reference:\n       int prev = -1;\n       for (int i = ind; i < cand.Length; i++){\n           if (currSum + cand[i] > targ) break;\n           if (prev == cand[i]) continue;\n           currComb.Add(cand[i]);\n           findComb(cand, targ, currSum + cand[i], currComb, i + 1);\n           currComb.RemoveAt(currComb.Count - 1);\n           prev = cand[i];\n       } ¬†Read moreTip352rakesh_joshiJun 20, 2016Question says\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nEach number in C may only be used once in the combination.\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\nA solution set is:\n[\n[1, 7],\n[1, 2, 5],\n[2, 6],\n[1, 1, 6]\n]\ni am confused of this  condition\nEach number in C may only be used once in the combination.\nas in this example it has the combination [1,1,6]  i.e. repeating 1's\nit is highly appreciable if somebody explains it. Thank you .¬†Read more215lowut02Sep 11, 2023Horrible problem tbh.¬†Read more301123420Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-25T15:07:32.000Z"
    },
    {
      "id": "leetcode-medium-find-first-and-last-position-of-element-in-sorted-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find First and Last Position of Element in Sorted Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] ans = { -1, -1 };\n        int start = search(nums, target, true);\n        int end = search(nums, target, false);\n        ans[0] = start;\n        ans[1] = end;\n        return ans;\n    }\n\n    static int search(int[] num, int target, boolean firstindex) {\n        int ans = -1;\n        int start = 0;\n        int end = num.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (num[mid] > target) {\n                end = mid - 1;\n            } else if (num[mid] < target) {\n                start = mid + 1;\n            } else {\n                ans = mid;\n                if (firstindex) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "readme": "34. Find First and Last Position of Element in Sorted ArraySolvedMediumTopicsCompaniesGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must¬†write an algorithm with¬†O(log n) runtime complexity.\n\n¬†\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n¬†\nConstraints:\n\n\n\t0 <= nums.length <= 105\n\t-109¬†<= nums[i]¬†<= 109\n\tnums is a non-decreasing array.\n\t-109¬†<= target¬†<= 109\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,855,513/6MAcceptance Rate47.3%TopicsArrayBinary SearchCompaniesSimilar QuestionsFirst Bad VersionEasyPlates Between CandlesMediumFind Target Indices After Sorting ArrayEasyDiscussion (313)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestNo comments yet.123432Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "Find First and Last Position of Element in Sorted Array\n\n          - Summary: The code uses arrays to store the input numbers and the result.  It employs a modified binary search algorithm (`search` function) twice: once to find the leftmost occurrence and once to find the rightmost occurrence of the target value.  The `searchRange` function orchestrates these searches and returns an array containing the start and end indices of the target's range, or {-1, -1} if not found.\n\n          - Time Complexity: O(log n). The binary search algorithm is used, which has a time complexity of O(log n), where n is the length of the input array.  The algorithm is called twice, but this does not change the overall time complexity.\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space to store the indices and intermediate results. The space used does not depend on the size of the input array."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-27T09:20:38.000Z"
    },
    {
      "id": "leetcode-medium-group-anagrams",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Group Anagrams",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> result = new ArrayList<>();\n        boolean[] visited = new boolean[strs.length];\n\n        for (int i = 0; i < strs.length; i++) {\n            if (visited[i]) continue;\n\n            List<String> group = new ArrayList<>();\n            group.add(strs[i]);\n            visited[i] = true;\n\n            for (int j = i + 1; j < strs.length; j++) {\n                if (!visited[j] && isAnagram(strs[i], strs[j])) {\n                    group.add(strs[j]);\n                    visited[j] = true;\n                }\n            }\n\n            result.add(group);\n        }\n\n        return result;\n    }\n\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n\n        char[] originalArr = s.toCharArray();\n        char[] modifiedArr = t.toCharArray();\n        Arrays.sort(originalArr);\n        Arrays.sort(modifiedArr);\n\n        return Arrays.equals(originalArr, modifiedArr);\n    }\n}",
        "readme": "49. Group AnagramsSolvedMediumTopicsCompaniesGiven an array of strings strs, group the anagrams together. You can return the answer in any order.\n\n¬†\nExample 1:\n\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n\n\n\tThere is no string in strs that can be rearranged to form \"bat\".\n\tThe strings \"nat\" and \"tan\" are anagrams as they can be rearranged to form each other.\n\tThe strings \"ate\", \"eat\", and \"tea\" are anagrams as they can be rearranged to form each other.\n\n\n\nExample 2:\n\n\nInput: strs = [\"\"]\n\nOutput: [[\"\"]]\n\n\nExample 3:\n\n\nInput: strs = [\"a\"]\n\nOutput: [[\"a\"]]\n\n\n¬†\nConstraints:\n\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted4,045,741/5.7MAcceptance Rate71.3%TopicsArrayHash TableStringSortingCompaniesSimilar QuestionsValid AnagramEasyGroup Shifted StringsMediumFind Resultant Array After Removing AnagramsEasyCount AnagramsHardDiscussion (336)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestHandsomeJensJan 24, 2024Just wanna give props to myself. This was my first medium :)¬†Read more53814NikitaMar 23, 2023 An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nInput:\nstrs = [\"\",\"\"]\nExpected:\n[[\"\",\"\"]]\nWhere are the letters or words?¬†Read moreAsk Question1968DIVITE DINESHFeb 06, 2024Finally can solve this after revisiting 5 times in 6 months.\nThis journey is going incredibly well. üöÄ¬†Read more1461Sawan KushwahOct 01, 2023Approach\ntake out string\nchar array\nsort it\nconvert to string\nuse this string as a key\nthen push all the related element to key¬†Read more17921Freeze FrancisAug 10, 2021This question was part of interview rounds of Amazon.\nFor folks preparing for FAANG interview please read my interview experience.\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b¬†Read more1403An-Wen DengFeb 06, 2024Hash table must be used, because this is a strings' question.\nOne tip:  strings are anagrams <=> same string after sorting. No need for frequency count unless the string is super long.\nHave a nice day!¬†Read more403Bohdan PozharskyiNov 02, 2013What does it mean \"return all groups\"? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?¬†Read more1134MrLebovskySep 01, 2023It says: \" You can return the answer in any order\", but console result is:\nOutput\n[[\"ddddddddddg\",\"dgggggggggg\"]]\nExpected\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\nWhy?¬†Read more468Mahdy KhayyamianFeb 01, 2015Why the output is list and not a list of list. What If there are multiple groups of anagrams?¬†Read more393SamMy89Nov 04, 2014I found nice solution in Java in the internet, and it worked. However, I really don't understand the question. It says\n\nreturn all groups of strings that are anagrams.\n\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need List<List<String>>. But in the problem description the method signature is given by List<String>. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?¬†Read more176123434Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "# Group Anagrams\n\n          **Summary:** The algorithm uses a boolean array to track visited strings and an ArrayList of ArrayLists to store the grouped anagrams. It iterates through the input string array, checking for unvisited strings. For each unvisited string, it forms a group of anagrams by comparing it with the remaining strings using a helper function 'isAnagram', which sorts the characters of two strings and compares them for equality. Finally, it adds the group to the result list.\n\n          - Time Complexity: O(NKlogK), where N is the number of strings and K is the maximum length of a string. This is because sorting each string takes O(KlogK) time, and the algorithm iterates through all strings and pairs of strings. The outer loop runs N times, and the nested loop runs at most N times.  The `isAnagram` function dominates the runtime complexity.\n          - Space Complexity: O(NK), where N is the number of strings and K is the maximum length of a string. This is because in the worst case, all strings could be anagrams of each other, resulting in a list of lists that has approximately NK characters in total. The space used by the `visited` array is O(N), which is dominated by the space used to store the results."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:38:02.000Z"
    },
    {
      "id": "leetcode-medium-longest-palindromic-substring",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Palindromic Substring",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        if (n < 2)\n            return s;\n\n        // Transform input string with separators to handle even palindromes\n        char[] t = new char[2 * n + 3];\n        t[0] = '^';\n        for (int i = 0; i < n; i++) {\n            t[2 * i + 1] = '#';\n            t[2 * i + 2] = s.charAt(i);\n        }\n        t[2 * n + 1] = '#';\n        t[2 * n + 2] = '$';\n\n        int[] p = new int[t.length];\n        int center = 0, right = 0;\n        int maxLen = 0, centerIndex = 0;\n\n        for (int i = 1; i < t.length - 1; i++) {\n            int mirror = 2 * center - i;\n\n            if (i < right)\n                p[i] = Math.min(right - i, p[mirror]);\n\n            // expand around i\n            while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) {\n                p[i]++;\n            }\n\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n\n            if (p[i] > maxLen) {\n                maxLen = p[i];\n                centerIndex = i;\n            }\n        }\n\n        int start = (centerIndex - maxLen) / 2;\n        return s.substring(start, start + maxLen);\n    }\n}",
        "readme": "5. Longest Palindromic SubstringSolvedMediumTopicsCompaniesHintGiven a string s, return the longest palindromic substring in s.\n\n¬†\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n¬†\nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted4,092,056/11.3MAcceptance Rate36.3%TopicsTwo PointersStringDynamic ProgrammingCompaniesHint 1How can we reuse a previously computed palindrome to compute a larger palindrome?Hint 2If ‚Äúaba‚Äù is a palindrome, is ‚Äúxabax‚Äù a palindrome? Similarly is ‚Äúxabay‚Äù a palindrome?Hint 3Complexity based hint:\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.Similar QuestionsShortest PalindromeHardPalindrome PermutationEasyPalindrome PairsHardLongest Palindromic SubsequenceMediumPalindromic SubstringsMediumMaximum Number of Non-overlapping Palindrome SubstringsHardDiscussion (496)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestZenMasterVNov 05, 2022Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills\n\" Please don't post any solutions in this discussion tab\"\nIt's almost the rule to find the exact opposite for the discussion of every question. I don't want to see your damned solution!¬†Read more1.3K13Akhil ChauhanOct 27, 2023More like longest palindromic nightmare¬†Read more2191SwetNov 04, 2022It took me an hour to solve this even though it's not that difficult but anyhow came to the conclusion that I need to do more practice.¬†Read more1273sanemdeepakJan 16, 2019For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?¬†Read more17720Neetika BansalJun 04, 2014From the leetcode blog, one of the methods of solving this is:\nA common mistake:\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\nReverse S and become S‚Äô. Find the longest common substring between S and S‚Äô, which must also be the longest palindromic substring.\nThis seemed to work, let‚Äôs see some examples below.\nFor example,\nS = ‚Äúcaba‚Äù, S‚Äô = ‚Äúabac‚Äù.\nThe longest common substring between S and S‚Äô is ‚Äúaba‚Äù, which is the answer.\nLet‚Äôs try another example:\nS = ‚Äúabacdfgdcaba‚Äù, S‚Äô = ‚Äúabacdgfdcaba‚Äù.\nThe longest common substring between S and S‚Äô is ‚Äúabacd‚Äù. Clearly, this is not a valid palindrome.\nWe could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring‚Äôs indices are the same as the reversed substring‚Äôs original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.\nIs this part correct?\nexample string: abcxycba\nreverse string:  abcxycba\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?¬†Read more949napoleonNov 08, 2013My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?¬†Read more10313Tomas SandvenApr 25, 2023I'm getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\ns =\nDid I break it?¬†Read moreFeedback47884danieNov 14, 2016I submitted my solution, and received a Time Limit Exceeded on this test case:\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\n\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug?\n¬†Read more4410miklerAug 25, 2017So I think I finally understood logic of test creators.\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG.\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\nif s == s[::-1]: return s¬†Read more254AlgoEngineJun 17, 2023Visualization of \"Expand from Centers\" solution:\n¬†Read more231123450Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "# Longest Palindromic Substring\n\n          **Summary:** The algorithm uses Manacher's algorithm to find the longest palindromic substring.  It employs a character array `t` to preprocess the input string `s`, adding special characters to handle even-length palindromes efficiently. An integer array `p` stores the lengths of palindromes centered at each position in `t`. The algorithm iteratively expands around each center, updating `p`, `center`, and `right` to track the longest palindrome found so far.\n\n          - Time Complexity: O(n) because the main loop iterates through the transformed string `t` once, which is linearly proportional to the length of the original string `s`.  The inner `while` loop's total iterations are also bounded by O(n).\n          - Space Complexity: O(n) because the algorithm uses an array `t` and an array `p`, both of which are linearly proportional to the length of the transformed string, which is O(n) compared to the original string."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T15:52:36.000Z"
    },
    {
      "id": "leetcode-medium-pow-x--n-",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Pow(x, n)",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double myPow(double x, int n) {\n        return Math.pow(x,n);\n    }\n}",
        "readme": "50. Pow(x, n)SolvedMediumTopicsCompaniesImplement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\n¬†\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\n\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\n\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\n¬†\nConstraints:\n\n\n\t-100.0 < x < 100.0\n\t-231 <= n <= 231-1\n\tn is an integer.\n\tEither x is not zero or n > 0.\n\t-104 <= xn <= 104\n\n¬†Seen this question in a real interview before?1/5YesNoAccepted2,366,908/6.3MAcceptance Rate37.4%TopicsMathRecursionCompaniesSimilar QuestionsSqrt(x)EasySuper PowMediumCount Collisions of Monkeys on a PolygonMediumDiscussion (499)Choose a typeCommentüí° Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestTyler MatchettFeb 16, 2023Here is a test case made by someone who was in a bad mood\nx=-1\nn=2147483647¬†Read moreTip59113mrkanesirFeb 18, 2023how am i supposed to NOT get stack overflow with n=2147483647 ...¬†Read more35719Soumyajit Dey SarkarJul 24, 2023return pow(x,n);\nBeats 100% of the Solution :)\nI have successfully unlocked my clown outfit.¬†Read more4249Linearly IndependentApr 07, 2022return x**n¬†Read more45326SylvexMar 18, 2023x =\n2.00000\nn =\n-2147483648\nWhat even is the point of this edge case???¬†Read more18825olooneyJul 06, 2018This is the 37th problem I've solved on the site and in the end I got a respectible 4ms solution. But honestly, It seems like its 2% algorithm, 98% fiddling with binary representations of signed integers and floating point numbers. I also note that, as of this writing, the problem has 1160 downvotes to 428 upvotes, so there's certainly some shared negativity out there.\nPersonally, I didn't enjoy this problem because I felt like I spent more time writing custom test cases for corner cases than I did programming. Frankly I cannot imagine getting this question in an interview and having the interviewer go, \"aha! but your solution doesn't account for the case when n is -2^31 and x is exactly -1.0! There's no way we'd hire such an incompetent programmer!\" And yet the way the acceptance tests are written, you need to nail every single corner case. Perhaps that frustration is limited to C/C++? Or there's a different algorithm that more naturally accounts for these edge cases?\nWhat was your experience? Would you agree or disagree with my thesis that this is the worst problem on the site?¬†Read more27411Rishabh MishraJul 24, 2023Someone just hates society\nn = INT_MIN & x = 1.0000000000001 wtf !!¬†Read more831shadowfax_Jan 31, 2022just has the onsite and the interviewer tdidn't want the recursive version but wanted the fast one with no recursion.¬†Read more725natitatiApr 15, 2023Is there something broken about testcase 305?¬†Read more424HitroMar 19, 2019I'm wondering why you guys are not using builtin Math.pow() method??\nPlease give me some insight.\nThank you :)¬†Read more618123450Copyright ¬© 2025 LeetCode. All rights reserved.",
        "notes": "Pow(x, n)\n\n          - Summary: The Java code uses the built-in Math.pow() function to compute x raised to the power of n.  No additional data structures are used. The function directly calls the Math.pow() method, which internally uses a highly optimized algorithm (likely involving logarithms and bit manipulation) to calculate the result. The result, a double-precision floating-point number representing x^n, is then returned.\n\n          - Time Complexity: O(1) - The Math.pow() function in Java has a constant time complexity because it's implemented using highly optimized native code.\n          - Space Complexity: O(1) - The function uses constant extra space, regardless of the input values of x and n."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T19:22:49.000Z"
    },
    {
      "id": "leetcode-hard-n-queens-ii",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "N-Queens II",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        // sets to track attacked columns and diagonals\n        unordered_set<int> cols, diag1, diag2;\n        int count = 0;\n\n        function<void(int)> backtrack = [&](int row) {\n            if (row == n) {\n                count++;\n                return;\n            }\n\n            for (int col = 0; col < n; col++) {\n                if (cols.count(col) || diag1.count(row - col) ||\n                    diag2.count(row + col))\n                    continue;\n\n                // place queen\n                cols.insert(col);\n                diag1.insert(row - col);\n                diag2.insert(row + col);\n\n                backtrack(row + 1);\n\n                // remove queen (backtrack)\n                cols.erase(col);\n                diag1.erase(row - col);\n                diag2.erase(row + col);\n            }\n        };\n\n        backtrack(0);\n        return count;\n    }\n};",
        "readme": "Backtracking\n\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return the number of distinct solutions to the¬†n-queens puzzle.\n\n¬†\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\n¬†\nConstraints:\n\n\n\t1 <= n <= 9",
        "notes": "# N-Queens II\n\n          **Summary:** This code implements a solution using C++. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-27T08:50:40.000Z"
    }
  ]
}